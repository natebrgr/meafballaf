<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throwable Bouncy Circle Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #000000;
            position: relative;
        }
        canvas {
            position: absolute;
            z-index: 5;
            background: transparent;
            pointer-events: auto;
        }
        #levelContainer, #countdown, #title {
            position: absolute;
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff;
            font-weight: bold;
            z-index: 2;
        }
        #title {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            white-space: nowrap;
        }
        #levelContainer {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            width: 120px;
            height: 60px;
            background: transparent;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
        }
        #levelContainer.flash-green {
            animation: flashGreenBorder 0.5s ease;
        }
        #levelContainer.flash-red {
            animation: flashRedBorder 0.5s ease;
        }
        #wallHits, #levelNumber {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Impact', sans-serif;
            font-size: 2.5em;
        }
        #wallHits {
            text-shadow: 0 0 5px #fff;
            border-right: 2px solid #e0e0e0;
        }
        #wallHits.bright-glow {
            text-shadow: 0 0 10px #fff, 0 0 2px var(--outline-color);
        }
        #levelNumber {
            color: rgb(11, 74, 28);
            text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100);
        }
        #levelNumber.flash-red {
            animation: flashRedLevel 0.5s ease;
        }
        #levelNumber.flash-white {
            animation: flashWhiteLevel 0.5s ease;
        }
        #countdown {
            left: 50%;
            transform: translateX(-50%);
            font-size: 4em;
            transition: opacity 0.5s ease;
            z-index: 10;
            pointer-events: none;
            color: #ffffff;
            text-shadow: 0 0 10px #000;
        }
        #livesCount, #hiScoreCount {
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff;
            font-size: 2.5em;
            position: absolute;
            z-index: 2;
            font-family: 'Impact', sans-serif;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            top: 40px;
        }
        #livesCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #livesCount.flash-red {
            animation: flashRed 0.5s ease;
        }
        #hiScoreCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #modeButton, #mapButton {
            position: absolute;
            z-index: 15;
        }
        #playButton {
            position: absolute;
            z-index: 20;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            font-size: 1em;
            display: block;
        }
        button {
            padding: 8px 16px;
            font-size: 1em;
            font-weight: bold;
            font-family: Arial, sans-serif;
            cursor: pointer;
            color: #ffffff;
            text-shadow: 0 0 5px #fff;
            background: transparent;
            border: 2px solid #ffffff;
            border-radius: 0;
            filter: drop-shadow(0 0 5px #fff);
            transition: none;
            z-index: 25;
            pointer-events: auto;
        }
        button:hover {
            filter: drop-shadow(0 0 5px #fff) brightness(85%);
        }
        #playButton.glow-green {
            animation: glowGreen 1s linear forwards;
        }
        #playButton.glow-red {
            animation: glowRed 1s linear forwards;
        }
        #modeButton.glow-white, #mapButton.glow-white {
            animation: glowWhite 1s linear forwards;
        }
        #playButton.recede, #modeButton.recede, #mapButton.recede {
            animation: recedeGlow 0.2s linear forwards;
        }
        #livesChange {
            position: absolute;
            z-index: 3;
            font-family: 'Impact', sans-serif;
            font-size: 0; /* Start at 0 size */
            top: 40px;
            left: calc(60px + 10px); /* Positioned right of livesCount with a 10px gap */
            pointer-events: none;
        }
        #livesChange.plus {
            color: green;
            animation: livesPlus 1.5s ease forwards;
        }
        #livesChange.minus {
            color: red;
            animation: livesMinus 1.5s ease forwards;
        }
        @keyframes glowGreen {
            0% { box-shadow: 0 0 5px rgb(11, 74, 28); }
            100% { box-shadow: 0 0 20px rgb(11, 74, 28); }
        }
        @keyframes glowRed {
            0% { box-shadow: 0 0 5px rgb(130, 33, 33); }
            100% { box-shadow: 0 0 20px rgb(130, 33, 33); }
        }
        @keyframes glowWhite {
            0% { box-shadow: 0 0 5px #ffffff; }
            100% { box-shadow: 0 0 20px #ffffff; }
        }
        @keyframes recedeGlow {
            0% { box-shadow: 0 0 20px; }
            100% { box-shadow: 0 0 0; }
        }
        @keyframes flashGreen {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
            50% { color: rgb(11, 74, 28); text-shadow: 0 0 5px #fff; border-color: rgb(11, 74, 28); }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
        }
        @keyframes flashRed {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 5px #fff; border-color: rgb(130, 33, 33); }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
        }
        @keyframes flashGreenBorder {
            0% { border-color: #e0e0e0; }
            50% { border-color: rgb(11, 74, 28); }
            100% { border-color: #e0e0e0; }
        }
        @keyframes flashRedBorder {
            0% { border-color: #e0e0e0; }
            50% { border-color: rgb(130, 33, 33); }
            100% { border-color: #e0e0e0; }
        }
        @keyframes flashRedLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        @keyframes flashWhiteLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: #e0e0e0; text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        @keyframes livesPlus {
            0% { font-size: 0; transform: rotate(0deg); opacity: 1; }
            33% { font-size: 2.5em; transform: rotate(27.5deg); opacity: 1; }
            66% { font-size: 2.5em; transform: rotate(27.5deg); opacity: 1; }
            100% { font-size: 0; transform: rotate(0deg); opacity: 0; }
        }
        @keyframes livesMinus {
            0% { font-size: 0; transform: rotate(0deg); opacity: 1; }
            33% { font-size: 2.5em; transform: rotate(27.5deg); opacity: 1; }
            66% { font-size: 2.5em; transform: rotate(27.5deg); opacity: 1; }
            100% { font-size: 0; transform: rotate(0deg); opacity: 0; }
        }
        canvas.flash-green {
            animation: flashGreen 0.5s ease;
        }
        canvas.flash-red {
            animation: flashRed 0.5s ease;
        }
    </style>
</head>
<body>
    <div id="title">SURVIVAL MODE</div>
    <div id="levelContainer">
        <div id="wallHits">0</div>
        <div id="levelNumber">1</div>
    </div>
    <div id="countdown" style="opacity: 0;"></div>
    <div id="livesCount">3</div>
    <div id="livesChange"></div>
    <div id="hiScoreCount">0</div>
    <button id="modeButton">MODE</button>
    <button id="mapButton">MAP</button>
    <canvas id="canvas"></canvas>
    <button id="playButton">PAUSE</button>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const levelContainer = document.getElementById('levelContainer');
        const levelNumber = document.getElementById('levelNumber');
        const countdownDisplay = document.getElementById('countdown');
        const wallHitsDisplay = document.getElementById('wallHits');
        const livesCount = document.getElementById('livesCount');
        const livesChange = document.getElementById('livesChange');
        const hiScoreCount = document.getElementById('hiScoreCount');
        const titleDisplay = document.getElementById('title');
        const modeButton = document.getElementById('modeButton');
        const mapButton = document.getElementById('mapButton');
        const playButton = document.getElementById('playButton');
        const borderWidth = 2;
        const defaultRadius = 30;
        const initialRadius = 60;
        const resizeHoldThreshold = 200;
    const circle = {
        x: 0,
        y: 0,
        radius: initialRadius,
        dx: 0,
        dy: 0,
        isDragging: false,
        dragTouchId: null,
        wasDraggingWhenPaused: false,
        lastX: 0,
        lastY: 0,
        lastTime: 0,
        wallContact: {
            left: { time: 0, inContact: false },
            right: { time: 0, inContact: false },
            top: { time: 0, inContact: false },
            bottom: { time: 0, inContact: false },
            boundary: { time: 0, inContact: false }
        },
        resizeTouchId: null,
        isResizing: false,
        resizeStartX: 0,
        resizeStartY: 0,
        initialRadius: initialRadius,
        resizeStartTime: 0,
        resizeTimer: null,
        hasBeenTouched: false
    };

    const gravity = 0.5;
    const friction = 0.98;
    const bounciness = 0.9;

    let isCountingDown = false;
    let countdown = 3;
    let countdownInterval = null;
    let countdownOpacity = 0;
    let wallHits = 0;
    let level = 1;
    let isTrackingHits = false;
    let lives = 3;
    let hiScore = 0;
    let isPaused = false;

    let previousLives = lives;
    let previousLevel = level;
    let previousHiScore = hiScore;
    let startingLives = lives;

    let currentMode = 'survival';
    let currentMap = 'rectangle';

    const trail = [];
    const maxTrailLength = 20;
    const trailFadeRate = 0.1;

    let holdTimers = { play: null, mode: null, map: null };
    let buttonActivated = { play: false, mode: false, map: false };

    const gameStates = {
        'survival-rectangle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: 3 },
        'endurance-rectangle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: Infinity },
        'survival-circle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: 3 },
        'endurance-circle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: Infinity }
    };

    let greenSection = null;
    let redSection = null;

    function assignSections() {
        if (currentMode === 'survival' && currentMap === 'rectangle') {
            const sections = [0, 1, 2];
            const greenIndex = Math.floor(Math.random() * sections.length);
            greenSection = sections.splice(greenIndex, 1)[0];
            const redIndex = Math.floor(Math.random() * sections.length);
            redSection = sections.splice(redIndex, 1)[0];
        } else {
            greenSection = null;
            redSection = null;
        }
    }

    function setCanvasSize() {
        const wallHitsTop = parseInt(window.getComputedStyle(levelContainer).top) || 40;
        const wallHitsHeight = levelContainer.offsetHeight || 60;
        const wallHitsBottom = wallHitsTop + wallHitsHeight;
        const buttonHeight = modeButton.offsetHeight || 36;
        const canvasShrink = 10;
        const snugGap = 5;

        const availableHeight = window.innerHeight - wallHitsBottom - canvasShrink - buttonHeight - snugGap;
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.style.width = `${window.innerWidth * 0.9}px`;
        canvas.style.height = `${availableHeight - 2 * borderWidth}px`;
        canvas.width = window.innerWidth * 0.9 * pixelRatio;
        canvas.height = (availableHeight - 2 * borderWidth) * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);

        const canvasLeft = (window.innerWidth - (window.innerWidth * 0.9)) / 2;
        const canvasTop = wallHitsBottom + snugGap;
        canvas.style.top = `${canvasTop}px`;
        canvas.style.left = `${canvasLeft}px`;

        const canvasBottom = canvasTop + (availableHeight - 2 * borderWidth);
        countdownDisplay.style.top = `${canvasTop + 10}px`;

        const buttonTop = canvasBottom + snugGap;
        modeButton.style.top = `${buttonTop}px`;
        modeButton.style.left = `${canvasLeft}px`;

        mapButton.style.top = `${buttonTop}px`;
        mapButton.style.right = `${canvasLeft}px`;

        playButton.style.top = `${buttonTop}px`;

        livesCount.style.left = `${canvasLeft}px`;
        livesChange.style.left = `${canvasLeft + 60 + 10}px`; // Position right of livesCount
        hiScoreCount.style.right = `${canvasLeft}px`;

        constrainCircle();
    }

    document.addEventListener('DOMContentLoaded', () => {
        setCanvasSize();
        assignSections();
        requestAnimationFrame(() => setCanvasSize());
    });
    window.addEventListener('resize', setCanvasSize);

    function updateDisplay() {
        if (lives !== previousLives) {
            if (lives > previousLives) {
                livesCount.classList.remove('flash-green', 'flash-red');
                void livesCount.offsetHeight;
                livesCount.classList.add('flash-green');
                livesChange.textContent = '+1';
                livesChange.classList.remove('plus', 'minus');
                void livesChange.offsetHeight; // Reset animation
                livesChange.classList.add('plus');
            } else if (lives < previousLives) {
                livesCount.classList.remove('flash-green', 'flash-red');
                void livesCount.offsetHeight;
                livesCount.classList.add('flash-red');
                livesChange.textContent = '-1';
                livesChange.classList.remove('plus', 'minus');
                void livesChange.offsetHeight; // Reset animation
                livesChange.classList.add('minus');
            }
            previousLives = lives;
        }

        if (level !== previousLevel) {
            if (level < previousLevel) {
                levelNumber.classList.remove('flash-red', 'flash-white');
                void levelNumber.offsetHeight;
                levelNumber.classList.add('flash-red');
                levelContainer.classList.remove('flash-green', 'flash-red');
                void levelContainer.offsetHeight;
                levelContainer.classList.add('flash-red');
            } else if (level > previousLevel) {
                levelNumber.classList.remove('flash-red', 'flash-white');
                void levelNumber.offsetHeight;
                levelNumber.classList.add('flash-white');
                levelContainer.classList.remove('flash-green', 'flash-red');
                void levelContainer.offsetHeight;
                levelContainer.classList.add('flash-green');
            }
            previousLevel = level;
        }

        if (hiScore !== previousHiScore) {
            if (hiScore > previousHiScore) {
                hiScoreCount.classList.remove('flash-green');
                void hiScoreCount.offsetHeight;
                hiScoreCount.classList.add('flash-green');
            }
            previousHiScore = hiScore;
        }

        levelNumber.textContent = `${level}`;
        livesCount.textContent = lives === Infinity ? '∞' : lives;
        hiScoreCount.textContent = hiScore;
        titleDisplay.textContent = currentMode === 'survival' ? 'SURVIVAL MODE' : 'ENDURANCE MODE';
        setCanvasSize();

        playButton.textContent = isPaused ? 'RESUME' : 'PAUSE';
        countdownDisplay.style.opacity = countdownOpacity;
        countdownDisplay.textContent = countdown;

        wallHitsDisplay.textContent = `${wallHits}`;
    }

    function constrainCircle() {
        if (currentMap === 'rectangle') {
            circle.x = Math.max(circle.radius, Math.min(canvas.width / (window.devicePixelRatio || 1) - circle.radius, circle.x));
            circle.y = Math.max(circle.radius, Math.min(canvas.height / (window.devicePixelRatio || 1) - circle.radius, circle.y));
        } else {
            const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
            const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
            const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
            if (distFromCenter + circle.radius > maxRadius) {
                const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                circle.x = centerX + Math.cos(angle) * (maxRadius - circle.radius);
                circle.y = centerY + Math.sin(angle) * (maxRadius - circle.radius);
            }
        }
    }

    function saveState() {
        const key = `${currentMode}-${currentMap}`;
        gameStates[key] = {
            level,
            lives,
            hiScore,
            circle: {
                x: circle.x,
                y: circle.y,
                radius: circle.radius,
                dx: circle.dx,
                dy: circle.dy,
                isDragging: circle.isDragging,
                dragTouchId: circle.dragTouchId,
                lastX: circle.lastX,
                lastY: circle.lastY,
                lastTime: circle.lastTime,
                wasDraggingWhenPaused: circle.wasDraggingWhenPaused,
                hasBeenTouched: circle.hasBeenTouched
            },
            trail: [...trail],
            wallHits,
            isTrackingHits,
            isPaused,
            isCountingDown,
            countdown,
            countdownOpacity,
            wasDraggingWhenPaused: circle.wasDraggingWhenPaused,
            startingLives,
            greenSection,
            redSection
        };
        if (isCountingDown) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
    }

    function loadState(mode, map) {
        const key = `${mode}-${map}`;
        const state = gameStates[key];
        level = state.level;
        lives = state.lives;
        hiScore = state.hiScore;
        wallHits = state.wallHits;
        isTrackingHits = state.isTrackingHits;
        isPaused = state.isPaused;
        isCountingDown = state.isCountingDown;
        countdown = state.countdown;
        countdownOpacity = state.countdownOpacity;
        circle.wasDraggingWhenPaused = state.wasDraggingWhenPaused;
        startingLives = state.startingLives !== undefined ? state.startingLives : (mode === 'survival' ? 3 : Infinity);
        greenSection = state.greenSection !== undefined ? state.greenSection : null;
        redSection = state.redSection !== undefined ? state.redSection : null;

        if (!greenSection && !redSection && mode === 'survival' && map === 'rectangle') {
            assignSections();
        }

        if (state.circle.x !== undefined) {
            circle.x = state.circle.x;
            circle.y = state.circle.y;
            circle.radius = state.circle.radius || initialRadius;
            circle.dx = state.circle.dx;
            circle.dy = state.circle.dy;
            circle.isDragging = false; // Force reset to avoid drag state leak
            circle.dragTouchId = null;
            circle.lastX = state.lastX;
            circle.lastY = state.lastY;
            circle.lastTime = state.lastTime || Date.now();
            circle.hasBeenTouched = state.circle.hasBeenTouched || false;
        } else {
            circle.x = (canvas.width / (window.devicePixelRatio || 1)) / 2;
            circle.y = (canvas.height / (window.devicePixelRatio || 1)) / 2;
            circle.radius = initialRadius;
            circle.dx = 0;
            circle.dy = 0;
            circle.isDragging = false;
            circle.dragTouchId = null;
            circle.lastX = circle.x;
            circle.lastY = circle.y;
            circle.lastTime = Date.now();
            circle.hasBeenTouched = false;
        }

        constrainCircle();
        trail.length = 0;
        if (state.trail && state.trail.length > 0) {
            trail.push(...state.trail);
        }

        currentMode = mode;
        currentMap = map;
        buttonActivated = { play: false, mode: false, map: false };
        holdTimers = { play: null, mode: null, map: null };
        [playButton, modeButton, mapButton].forEach(btn => {
            btn.classList.remove('glow-green', 'glow-red', 'glow-white', 'recede');
        });

        updateDisplay();
        drawScene();
    }

    function getCircleColor(counterColor) {
        if (counterColor === 'rgb(11, 74, 28)') return 'rgba(11, 74, 28, 0.7)';
        if (counterColor === 'rgb(130, 33, 33)') return 'rgba(130, 33, 33, 0.7)';
        return 'rgba(255, 255, 255, 0.7)';
    }

    function getBorderColor(counterColor) {
        if (counterColor === 'rgb(11, 74, 28)') return 'rgb(11, 74, 28)';
        if (counterColor === 'rgb(130, 33, 33)') return 'rgb(130, 33, 33)';
        return '#ffffff';
    }

    function getCrosshairColor(counterColor) {
        if (counterColor === 'rgb(11, 74, 28)') return 'rgba(0, 0, 0, 0.7)';
        if (counterColor === 'rgb(130, 33, 33)') return 'rgba(0, 0, 0, 0.7)';
        return 'rgba(0, 0, 0, 0.7)';
    }

    function lightenColor(color) {
        if (color === 'rgb(11, 74, 28)') return 'rgba(11, 74, 28,';
        if (color === 'rgb(130, 33, 33)') return 'rgba(130, 33, 33,';
        return 'rgba(255, 255, 255,';
    }

    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
        const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
        const sectionHeight = canvasHeight / 3;
        const pixelRatio = window.devicePixelRatio || 1;

        if (currentMode === 'survival' && currentMap === 'rectangle') {
            if (greenSection !== null) {
                ctx.fillStyle = 'rgb(11, 74, 28)';
                ctx.fillRect(0, greenSection * sectionHeight, canvasWidth, sectionHeight);
            }
            if (redSection !== null) {
                ctx.fillStyle = 'rgb(130, 33, 33)';
                ctx.fillRect(0, redSection * sectionHeight, canvasWidth, sectionHeight);
            }

            ctx.font = 'bold 40px Impact, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;

            const greenLives = startingLives <= 3 ? startingLives + 1 : (lives > 2 ? lives + 1 : 4);
            const redLives = startingLives <= 3 ? Math.max(startingLives - 1, 1) : (lives > 2 ? Math.max(lives - 1, 1) : 2);
            const blackSection = [0, 1, 2].find(s => s !== greenSection && s !== redSection);
            const blackLives = startingLives <= 3 ? startingLives : (lives > 2 ? lives : 3);

            if (greenSection !== null) {
                ctx.fillStyle = 'rgb(11, 74, 28)';
                ctx.fillText(`+${greenLives - lives}`, 40, greenSection * sectionHeight + sectionHeight / 2);
                ctx.fillText(`+${greenLives - lives}`, canvasWidth - 40, greenSection * sectionHeight + sectionHeight / 2);
            }
            if (redSection !== null) {
                ctx.fillStyle = 'rgb(130, 33, 33)';
                ctx.fillText(`${redLives - lives >= 0 ? '+' : ''}${redLives - lives}`, 40, redSection * sectionHeight + sectionHeight / 2);
                ctx.fillText(`${redLives - lives >= 0 ? '+' : ''}${redLives - lives}`, canvasWidth - 40, redSection * sectionHeight + sectionHeight / 2);
            }
            if (blackSection !== null) {
                ctx.fillStyle = '#000';
                ctx.fillText(`${blackLives - lives >= 0 ? '+' : ''}${blackLives - lives}`, 40, blackSection * sectionHeight + sectionHeight / 2);
                ctx.fillText(`${blackLives - lives >= 0 ? '+' : ''}${blackLives - lives}`, canvasWidth - 40, blackSection * sectionHeight + sectionHeight / 2);
            }

            ctx.shadowBlur = 0;
        }

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = borderWidth * 2;
        if (currentMap === 'rectangle') {
            ctx.strokeRect(0, 0, canvasWidth, canvasHeight);
        } else {
            ctx.beginPath();
            ctx.arc(canvasWidth / 2, canvasHeight / 2, Math.min(canvasWidth, canvasHeight) / 2 - borderWidth, 0, Math.PI * 2);
            ctx.stroke();
        }

        const greenColor = 'rgb(11, 74, 28)';
        let counterColor = '#e0e0e0';
        if (wallHits === level) counterColor = greenColor;
        else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';

        const circleColor = getCircleColor(counterColor);
        const borderColor = getBorderColor(counterColor);
        const crosshairColor = getCrosshairColor(counterColor);
        const trailBaseColor = lightenColor(counterColor);

        if (trail.length > 1) {
            ctx.beginPath();
            ctx.lineWidth = circle.radius * 2;
            ctx.lineCap = 'round';
            for (let i = 0; i < trail.length - 1; i++) {
                const start = trail[i];
                const end = trail[i + 1];
                const opacity = start.opacity * (1 - (i / trail.length));
                ctx.strokeStyle = `${trailBaseColor} ${opacity})`;
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
        }

        ctx.beginPath();
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        ctx.fillStyle = circleColor;
        ctx.fill();
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2 * pixelRatio;
        ctx.stroke();
        ctx.closePath();
        ctx.shadowBlur = 0;

        ctx.beginPath();
        ctx.strokeStyle = crosshairColor;
        ctx.lineWidth = 1 * pixelRatio;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10 * pixelRatio;
        const crossSize = 15;
        ctx.moveTo(circle.x - crossSize, circle.y);
        ctx.lineTo(circle.x + crossSize, circle.y);
        ctx.moveTo(circle.x, circle.y - crossSize);
        ctx.lineTo(circle.x, circle.y + crossSize);
        ctx.stroke();
        ctx.shadowBlur = 0;

        const shouldShowHoldingText = (!isPaused && circle.isDragging) || (isPaused && circle.wasDraggingWhenPaused);
        if (shouldShowHoldingText) {
            const text = "HOLDING";
            const fontSize = 24;
            const textRadius = circle.radius + 60;
            const totalLetters = text.length * 4;
            const anglePerLetter = (2 * Math.PI) / totalLetters;

            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 5 * pixelRatio;

            const startAngles = [-Math.PI / 2, 0, Math.PI / 2, Math.PI];
            for (let instance = 0; instance < 4; instance++) {
                const startAngle = startAngles[instance];
                for (let i = 0; i < text.length; i++) {
                    const angle = startAngle + (i * anglePerLetter);
                    const x = circle.x + textRadius * Math.cos(angle);
                    const y = circle.y + textRadius * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.fillText(text[i], 0, 0);
                    ctx.restore();
                }
            }
            ctx.shadowBlur = 0;
        }

        const offset = circle.radius + 30;

        ctx.font = 'bold 40px Impact, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = counterColor;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
        if (counterColor === 'rgb(11, 74, 28)') {
            ctx.shadowColor = 'rgb(50, 200, 100)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(wallHits, circle.x, circle.y - offset);
            ctx.fillText(wallHits, circle.x, circle.y + offset);
            ctx.fillText(wallHits, circle.x - offset, circle.y);
            ctx.fillText(wallHits, circle.x + offset, circle.y);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
        } else if (counterColor === 'rgb(130, 33, 33)') {
            ctx.shadowColor = 'rgb(255, 80, 80)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(wallHits, circle.x, circle.y - offset);
            ctx.fillText(wallHits, circle.x, circle.y + offset);
            ctx.fillText(wallHits, circle.x - offset, circle.y);
            ctx.fillText(wallHits, circle.x + offset, circle.y);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
        }
        ctx.fillText(wallHits, circle.x, circle.y - offset);
        ctx.fillText(wallHits, circle.x, circle.y + offset);
        ctx.fillText(wallHits, circle.x - offset, circle.y);
        ctx.fillText(wallHits, circle.x + offset, circle.y);

        ctx.fillStyle = greenColor;
        ctx.shadowColor = 'rgb(50, 200, 100)';
        ctx.shadowBlur = 2 * pixelRatio;
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10 * pixelRatio;
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);

        ctx.shadowBlur = 0;
    }

    function updatePhysics() {
        if (isPaused) {
            if (circle.isDragging) {
                circle.dx = 0;
                circle.dy = 0;
            }
            return;
        }

        const currentTime = Date.now();

        if (!circle.isDragging) {
            circle.dy += gravity;
            circle.x += circle.dx;
            circle.y += circle.dy;
            circle.dx *= friction;
            circle.dy *= friction;

            const velocity = Math.sqrt(circle.dx * circle.dx + circle.dy * circle.dy);
            const trailLength = Math.min(maxTrailLength, Math.floor(velocity / 10));
            trail.unshift({ x: circle.x, y: circle.y, opacity: 1 });
            while (trail.length > trailLength) trail.pop();
            for (let i = 0; i < trail.length; i++) {
                trail[i].opacity -= trailFadeRate;
                if (trail[i].opacity <= 0) trail.splice(i, 1);
            }

            let walls;
            if (currentMap === 'rectangle') {
                walls = [
                    { name: 'right', edge: canvas.width / (window.devicePixelRatio || 1), pos: circle.x + circle.radius, velocity: circle.dx, isContact: circle.x + circle.radius >= canvas.width / (window.devicePixelRatio || 1) },
                    { name: 'left', edge: 0, pos: circle.x - circle.radius, velocity: circle.dx, isContact: circle.x - circle.radius <= 0 },
                    { name: 'bottom', edge: canvas.height / (window.devicePixelRatio || 1), pos: circle.y + circle.radius, velocity: circle.dy, isContact: circle.y + circle.radius >= canvas.height / (window.devicePixelRatio || 1) },
                    { name: 'top', edge: 0, pos: circle.y - circle.radius, velocity: circle.dy, isContact: circle.y - circle.radius <= 0 }
                ];
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                const isContact = distFromCenter + circle.radius >= radius;
                walls = [{ name: 'boundary', edge: radius, pos: distFromCenter + circle.radius, velocity: 0, isContact }];
            }

            walls.forEach(wall => {
                const contact = circle.wallContact[wall.name];
                if (wall.isContact) {
                    if (!contact.inContact) {
                        contact.inContact = true;
                        contact.time = currentTime;
                        if (isTrackingHits) {
                            wallHits++;
                            wallHitsDisplay.textContent = `${wallHits}`;
                            const greenColor = 'rgb(11, 74, 28)';
                            let counterColor = '#e0e0e0';
                            if (wallHits === level) counterColor = greenColor;
                            else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';
                            wallHitsDisplay.style.color = counterColor;
                            if (counterColor === '#e0e0e0') {
                                wallHitsDisplay.classList.remove('bright-glow');
                                wallHitsDisplay.style.textShadow = '0 0 5px #fff';
                            } else {
                                wallHitsDisplay.classList.add('bright-glow');
                                const outlineColor = counterColor === greenColor ? 'rgb(50, 200, 100)' : 'rgb(255, 80, 80)';
                                wallHitsDisplay.style.setProperty('--outline-color', outlineColor);
                                wallHitsDisplay.style.textShadow = `0 0 10px #fff, 0 0 2px ${outlineColor}`;
                            }
                        }
                    }
                } else {
                    if (contact.inContact) {
                        contact.inContact = false;
                    }
                }
            });

            if (currentMap === 'rectangle') {
                if (circle.x + circle.radius > canvas.width / (window.devicePixelRatio || 1)) {
                    circle.x = (canvas.width / (window.devicePixelRatio || 1)) - circle.radius;
                    circle.dx = -circle.dx * bounciness;
                } else if (circle.x - circle.radius < 0) {
                    circle.x = circle.radius;
                    circle.dx = -circle.dx * bounciness;
                }
                if (circle.y + circle.radius > canvas.height / (window.devicePixelRatio || 1)) {
                    circle.y = (canvas.height / (window.devicePixelRatio || 1)) - circle.radius;
                    circle.dy = -circle.dy * bounciness;
                } else if (circle.y - circle.radius < 0) {
                    circle.y = circle.radius;
                    circle.dy = -circle.dy * bounciness;
                }
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                if (distFromCenter + circle.radius >= radius) {
                    const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                    circle.x = centerX + Math.cos(angle) * (radius - circle.radius);
                    circle.y = centerY + Math.sin(angle) * (radius - circle.radius);
                    const speed = Math.sqrt(circle.dx ** 2 + circle.dy ** 2);
                    circle.dx = -Math.cos(angle) * speed * bounciness;
                    circle.dy = -Math.sin(angle) * speed * bounciness;
                }
            }
        }
    }

    function startCountdown(isResuming = false) {
        if (!isResuming) {
            isCountingDown = true;
            countdown = 3;
            wallHits = 0;
            wallHitsDisplay.textContent = `${wallHits}`;
            wallHitsDisplay.style.color = '#e0e0e0';
            wallHitsDisplay.classList.remove('bright-glow');
            wallHitsDisplay.style.textShadow = '0 0 5px #fff';
            isTrackingHits = true;
            countdownOpacity = 1;
        } else {
            isCountingDown = true;
        }
        countdownDisplay.style.opacity = countdownOpacity;
        countdownDisplay.textContent = countdown;

        if (countdownInterval) clearInterval(countdownInterval);
        countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                countdownDisplay.textContent = countdown;
            } else {
                countdownOpacity = 0;
                countdownDisplay.style.opacity = countdownOpacity;
                clearInterval(countdownInterval);
                countdownInterval = null;
                isCountingDown = false;
                updateDisplay();
            }
        }, 1000);
    }

    function getMousePos(e, touchId = null) {
        const rect = canvas.getBoundingClientRect();
        if (touchId !== null && e.touches) {
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === touchId) {
                    return {
                        x: e.touches[i].clientX - rect.left,
                        y: e.touches[i].clientY - rect.top
                    };
                }
            }
        }
        return {
            x: (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left,
            y: (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top
        };
    }

    function getScreenPos(e, touchId = null) {
        if (touchId !== null && (e.touches || e.changedTouches)) {
            const touches = e.changedTouches || e.touches;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === touchId) {
                    return {
                        x: touches[i].clientX,
                        y: touches[i].clientY
                    };
                }
            }
        }
        return {
            x: e.clientX || (e.touches && e.touches[0].clientX) || (e.changedTouches && e.changedTouches[0].clientX),
            y: e.clientY || (e.touches && e.touches[0].clientY) || (e.changedTouches && e.changedTouches[0].clientY)
        };
    }

    function handleCanvasTap(e) {
        if (isPaused) return;
        const pos = getMousePos(e);
        e.preventDefault();

        const originalX = circle.x;
        const originalY = circle.y;

        if (circle.isDragging) return;

        if (!circle.hasBeenTouched) {
            circle.hasBeenTouched = true;
            startCountdown();
            circle.x = pos.x;
            circle.y = pos.y;
            constrainCircle();
            return;
        }

        if (isCountingDown) {
            if (wallHits === level) {
                isTrackingHits = false;
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    countdownOpacity = 0;
                    countdownDisplay.style.opacity = countdownOpacity;
                    isCountingDown = false;
                }
                const completedLevel = level;
                level++;
                let flashColor = null;

                if (currentMode === 'survival' && currentMap === 'rectangle') {
                    const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                    const sectionHeight = canvasHeight / 3;
                    const circleSection = Math.floor(originalY / sectionHeight); // Use original position

                    let baseLives;
                    if (startingLives > 3 && lives < 3) baseLives = 3;
                    else if (startingLives > 3 && lives > 2) baseLives = lives;
                    else baseLives = startingLives;

                    if (circleSection === greenSection) {
                        lives = baseLives + 1;
                        flashColor = 'flash-green';
                    } else if (circleSection === redSection) {
                        lives = Math.max(baseLives - 1, 1);
                        flashColor = 'flash-red';
                    } else {
                        lives = baseLives;
                    }
                } else if (currentMode === 'survival') {
                    lives = 3;
                }

                if (completedLevel > hiScore) hiScore = completedLevel;
                wallHits = 0;
                if (flashColor) {
                    canvas.classList.remove('flash-green', 'flash-red');
                    void canvas.offsetHeight;
                    canvas.classList.add(flashColor);
                }
                startingLives = lives;
                assignSections();
                saveState();
                updateDisplay();
                startCountdown();
            }
            circle.x = pos.x;
            circle.y = pos.y;
            constrainCircle();
            return;
        }

        // New tap-to-move and win/lose logic using original position
        if (wallHits === level) {
            isTrackingHits = false;
            const completedLevel = level;
            level++;
            let flashColor = null;

            if (currentMode === 'survival' && currentMap === 'rectangle') {
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                const sectionHeight = canvasHeight / 3;
                const circleSection = Math.floor(originalY / sectionHeight); // Use original position

                let baseLives;
                if (startingLives > 3 && lives < 3) baseLives = 3;
                else if (startingLives > 3 && lives > 2) baseLives = lives;
                else baseLives = startingLives;

                if (circleSection === greenSection) {
                    lives = baseLives + 1;
                    flashColor = 'flash-green';
                } else if (circleSection === redSection) {
                    lives = Math.max(baseLives - 1, 1);
                    flashColor = 'flash-red';
                } else {
                    lives = baseLives;
                }
            } else if (currentMode === 'survival') {
                lives = 3;
            }

            if (completedLevel > hiScore) hiScore = completedLevel;
            wallHits = 0;
            if (flashColor) {
                canvas.classList.remove('flash-green', 'flash-red');
                void canvas.offsetHeight;
                canvas.classList.add(flashColor);
            }
            startingLives = lives;
            assignSections();
            saveState();
            updateDisplay();
            startCountdown();
        } else if (wallHits > level && currentMode === 'survival') {
            lives--;
            if (lives <= 0) {
                level = 1;
                lives = 3;
                startingLives = 3;
            }
            wallHits = 0;
            saveState();
            updateDisplay();
            startCountdown();
        } else if (wallHits < level && currentMode === 'survival') {
            lives--;
            if (lives <= 0) {
                level = 1;
                lives = 3;
                startingLives = 3;
            }
            wallHits = 0;
            saveState();
            updateDisplay();
            startCountdown();
        } else {
            wallHits = 0;
            startCountdown();
        }

        circle.x = pos.x;
        circle.y = pos.y;
        constrainCircle();
    }

    function startDragging(e) {
        if (isPaused && !circle.wasDraggingWhenPaused) return;
        const pos = getMousePos(e, e.touches ? e.touches[0].identifier : null);
        e.preventDefault();
        circle.isDragging = true;
        circle.dragTouchId = e.touches ? e.touches[0].identifier : null;
        circle.lastX = pos.x;
        circle.lastY = pos.y;
        circle.lastTime = Date.now();
        circle.dx = 0;
        circle.dy = 0;
        circle.x = pos.x;
        circle.y = pos.y;
        constrainCircle();
        if (!isPaused) trail.length = 0;
        buttonActivated = { play: false, mode: false, map: false };
        drawScene();
    }

    function startResizing(e) {
        if (!circle.isDragging || circle.isResizing || e.touches.length < 2) return;
        if (isPaused && !circle.wasDraggingWhenPaused) return;

        const dragTouchIndex = Array.from(e.touches).findIndex(t => t.identifier === circle.dragTouchId);
        if (dragTouchIndex === -1) return;

        const otherTouch = e.touches[dragTouchIndex === 0 ? 1 : 0];
        const pos = getMousePos(e, otherTouch.identifier);
        const canvasRect = canvas.getBoundingClientRect();
        const isOverCanvas = (
            otherTouch.clientX >= canvasRect.left &&
            otherTouch.clientX <= canvasRect.right &&
            otherTouch.clientY >= canvasRect.top &&
            otherTouch.clientY <= canvasRect.bottom
        );

        if (isOverCanvas) {
            circle.resizeTouchId = otherTouch.identifier;
            circle.resizeStartX = pos.x;
            circle.resizeStartY = pos.y;
            circle.initialRadius = circle.radius;
            circle.resizeStartTime = Date.now();
            circle.resizeTimer = setTimeout(() => {
                if (circle.resizeTouchId !== null) {
                    circle.isResizing = true;
                }
            }, resizeHoldThreshold);
        }
    }

    function drag(e) {
        if (circle.isDragging && !circle.isResizing) {
            const pos = getMousePos(e, circle.dragTouchId);

            if (currentMap === 'rectangle') {
                pos.x = Math.max(circle.radius, Math.min((canvas.width / (window.devicePixelRatio || 1)) - circle.radius, pos.x));
                pos.y = Math.max(circle.radius, Math.min((canvas.height / (window.devicePixelRatio || 1)) - circle.radius, pos.y));
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth - circle.radius;
                const dx = pos.x - centerX;
                const dy = pos.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > maxRadius) {
                    const angle = Math.atan2(dy, dx);
                    pos.x = centerX + Math.cos(angle) * maxRadius;
                    pos.y = centerY + Math.sin(angle) * maxRadius;
                }
            }

            circle.x = pos.x;
            circle.y = pos.y;

            if (!isPaused) {
                const currentTime = Date.now();
                const dt = (currentTime - circle.lastTime) / 1000;
                if (dt > 0) {
                    circle.dx = (pos.x - circle.lastX) / dt;
                    circle.dy = (pos.y - circle.lastY) / dt;
                }
                circle.lastTime = currentTime;
            }
            circle.lastX = pos.x;
            circle.lastY = pos.y;
        }

        if (circle.isResizing) {
            const resizePos = getMousePos(e, circle.resizeTouchId);
            const dx = resizePos.x - circle.x;
            const dy = resizePos.y - circle.y;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            const initialDistance = Math.sqrt(
                (circle.resizeStartX - circle.x) ** 2 + 
                (circle.resizeStartY - circle.y) ** 2
            );
            const distanceDelta = currentDistance - initialDistance;

            const newRadius = Math.max(defaultRadius, circle.initialRadius + distanceDelta / 2);
            let maxAllowedRadius;

            if (currentMap === 'rectangle') {
                maxAllowedRadius = Math.min(
                    circle.x, 
                    (canvas.width / (window.devicePixelRatio || 1)) - circle.x,
                    circle.y,
                    (canvas.height / (window.devicePixelRatio || 1)) - circle.y
                );
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const distToCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                maxAllowedRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth - distToCenter;
            }

            circle.radius = Math.min(newRadius, maxAllowedRadius);
        }

        const screenPos = getScreenPos(e, circle.dragTouchId);
        const target = document.elementFromPoint(screenPos.x, screenPos.y);

        if (target === playButton) {
            if (!holdTimers.play && !buttonActivated.play) {
                playButton.classList.remove('glow-green', 'glow-red', 'recede');
                playButton.classList.add(isPaused ? 'glow-green' : 'glow-red');
                holdTimers.play = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === playButton) {
                        playButton.classList.remove('glow-green', 'glow-red');
                        playButton.classList.add('recede');
                        if (isPaused) {
                            isPaused = false;
                            circle.lastX = getMousePos(e, circle.dragTouchId).x;
                            circle.lastY = getMousePos(e, circle.dragTouchId).y;
                            circle.lastTime = Date.now();
                            circle.dx = 0;
                            circle.dy = 0;
                            if (gameStates[`${currentMode}-${currentMap}`].isCountingDown) startCountdown(true);
                        } else {
                            circle.wasDraggingWhenPaused = circle.isDragging;
                            isPaused = true;
                            saveState();
                        }
                        updateDisplay();
                        buttonActivated.play = true;
                    }
                    holdTimers.play = null;
                }, 1000);
            }
        } else {
            if (holdTimers.play) {
                clearTimeout(holdTimers.play);
                holdTimers.play = null;
                playButton.classList.remove('glow-green', 'glow-red');
                playButton.classList.add('recede');
            }
            if (buttonActivated.play && target !== playButton) buttonActivated.play = false;
        }

        if (target === modeButton) {
            if (!holdTimers.mode && !buttonActivated.mode) {
                modeButton.classList.remove('glow-white', 'recede');
                modeButton.classList.add('glow-white');
                holdTimers.mode = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === modeButton) {
                        modeButton.classList.remove('glow-white');
                        modeButton.classList.add('recede');
                        if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
                        isPaused = true;
                        saveState();
                        currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
                        circle.hasBeenTouched = false;
                        loadState(currentMode, currentMap);
                        updateDisplay();
                        buttonActivated.mode = true;
                    }
                    holdTimers.mode = null;
                }, 1000);
            }
        } else {
            if (holdTimers.mode) {
                clearTimeout(holdTimers.mode);
                holdTimers.mode = null;
                modeButton.classList.remove('glow-white');
                modeButton.classList.add('recede');
            }
            if (buttonActivated.mode && target !== modeButton) buttonActivated.mode = false;
        }

        if (target === mapButton) {
            if (!holdTimers.map && !buttonActivated.map) {
                mapButton.classList.remove('glow-white', 'recede');
                mapButton.classList.add('glow-white');
                holdTimers.map = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === mapButton) {
                        mapButton.classList.remove('glow-white');
                        mapButton.classList.add('recede');
                        if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
                        isPaused = true;
                        saveState();
                        currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
                        circle.hasBeenTouched = false;
                        loadState(currentMode, currentMap);
                        updateDisplay();
                        buttonActivated.map = true;
                    }
                    holdTimers.map = null;
                }, 1000);
            }
        } else {
            if (holdTimers.map) {
                clearTimeout(holdTimers.map);
                holdTimers.map = null;
                mapButton.classList.remove('glow-white');
                mapButton.classList.add('recede');
            }
            if (buttonActivated.map && target !== mapButton) buttonActivated.map = false;
        }

        if (isPaused) saveState();
        drawScene();
    }

    function stopDragging(e) {
        if (!circle.isDragging) return;
        let touchId = circle.dragTouchId;
        if (e.touches && e.touches.length > 0) return;
        if (e.changedTouches) {
            let matched = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    matched = true;
                    break;
                }
            }
            if (!matched) return;
        }

        const screenPos = getScreenPos(e, touchId);
        const target = document.elementFromPoint(screenPos.x, screenPos.y);
        const canvasRect = canvas.getBoundingClientRect();
        const isOverCanvas = (
            screenPos.x >= canvasRect.left &&
            screenPos.x <= canvasRect.right &&
            screenPos.y >= canvasRect.top &&
            screenPos.y <= canvasRect.bottom
        );

        if (target === playButton && !buttonActivated.play) {
            playButton.click();
        } else if (target === modeButton && !buttonActivated.mode) {
            modeButton.classList.remove('glow-white');
            modeButton.classList.add('recede');
            if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
            saveState();
            currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
            circle.hasBeenTouched = false;
            loadState(currentMode, currentMap);
            updateDisplay();
        } else if (target === mapButton && !buttonActivated.map) {
            mapButton.classList.remove('glow-white');
            mapButton.classList.add('recede');
            if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
            saveState();
            currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
            circle.hasBeenTouched = false;
            loadState(currentMode, currentMap);
            updateDisplay();
        } else if (isOverCanvas && !circle.hasBeenTouched) {
            circle.hasBeenTouched = true;
            startCountdown();
        }

        circle.isDragging = false;
        circle.dragTouchId = null;
        Object.keys(holdTimers).forEach(key => {
            if (holdTimers[key]) {
                clearTimeout(holdTimers[key]);
                holdTimers[key] = null;
                if (key === 'play') {
                    playButton.classList.remove('glow-green', 'glow-red');
                    playButton.classList.add('recede');
                } else {
                    document.getElementById(key + 'Button').classList.remove('glow-white');
                    document.getElementById(key + 'Button').classList.add('recede');
                }
            }
        });
        buttonActivated = { play: false, mode: false, map: false };
        if (!circle.isDragging && isPaused) saveState();
        drawScene();

        // Ensure buttons are clickable by forcing a clean slate
        [modeButton, mapButton].forEach(btn => {
            btn.style.pointerEvents = 'auto'; // Reset pointer events
        });
    }

    function stopResizing(e) {
        if (circle.resizeTouchId === null) return;
        if (e.touches && e.touches.length > 1) return;
        if (e.changedTouches) {
            let matched = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === circle.resizeTouchId) {
                    matched = true;
                    break;
                }
            }
            if (!matched) return;
        }

        const elapsed = Date.now() - circle.resizeStartTime;
        if (!circle.isResizing && elapsed < resizeHoldThreshold && !isPaused) {
            circle.isDragging = false;
            circle.dragTouchId = null;
            circle.dx = 0;
            circle.dy = 0;
        }
        if (circle.isResizing) {
            circle.isResizing = false;
        }

        if (circle.resizeTimer) {
            clearTimeout(circle.resizeTimer);
            circle.resizeTimer = null;
        }
        circle.resizeTouchId = null;
        constrainCircle();
        if (isPaused) saveState();
        drawScene();
    }

    modeButton.addEventListener('click', () => {
        if (!isPaused) {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
        }
        saveState();
        currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
        circle.hasBeenTouched = false;
        loadState(currentMode, currentMap);
        updateDisplay();
        drawScene();
    });

    mapButton.addEventListener('click', () => {
        if (!isPaused) {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
        }
        saveState();
        currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
        circle.hasBeenTouched = false;
        loadState(currentMode, currentMap);
        updateDisplay();
        drawScene();
    });

    playButton.addEventListener('click', (e) => {
        if (isPaused) {
            isPaused = false;
            if (circle.isDragging) {
                const pos = getMousePos(e);
                circle.lastX = pos.x;
                circle.lastY = pos.y;
                circle.lastTime = Date.now();
                circle.dx = 0;
                circle.dy = 0;
            } else if (circle.wasDraggingWhenPaused) {
                circle.isDragging = false;
                circle.dragTouchId = null;
                constrainCircle();
                circle.dx = 0;
                circle.dy = 0;
            } else {
                constrainCircle();
                circle.dx = circle.dx || 0;
                circle.dy = circle.dy || 0;
            }
            circle.wasDraggingWhenPaused = false;
            if (gameStates[`${currentMode}-${currentMap}`].isCountingDown) startCountdown(true);
            updateDisplay();
        } else {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
            saveState();
            updateDisplay();
        }
        drawScene();
    });

    canvas.addEventListener('mousedown', (e) => {
        handleCanvasTap(e);
        startDragging(e);
    });
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', stopDragging);

    canvas.addEventListener('touchstart', (e) => {
        handleCanvasTap(e);
        startDragging(e);
        startResizing(e);
    });
    canvas.addEventListener('touchmove', drag);
    canvas.addEventListener('touchend', (e) => {
        stopDragging(e);
        stopResizing(e);
    });

    document.addEventListener('mouseup', stopDragging);
    document.addEventListener('touchend', (e) => {
        stopDragging(e);
        stopResizing(e);
    });

    modeButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1) {
            modeButton.click();
        }
    });

    mapButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1) {
            mapButton.click();
        }
    });

    playButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1) {
            playButton.click();
        }
    });

    function animate() {
        updatePhysics();
        drawScene();
        requestAnimationFrame(animate);
    }

    circle.x = window.innerWidth * 0.45;
    circle.y = window.innerHeight * 0.5;

    updateDisplay();
    drawScene();
    animate();
</script>

</body>
</html>
