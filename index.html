<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const levelContainer = document.getElementById('levelContainer');
    const levelNumber = document.getElementById('levelNumber');
    const countdownDisplay = document.getElementById('countdown');
    const wallHitsDisplay = document.getElementById('wallHits');
    const livesCount = document.getElementById('livesCount');
    const hiScoreCount = document.getElementById('hiScoreCount');
    const titleDisplay = document.getElementById('title');
    const modeButton = document.getElementById('modeButton');
    const mapButton = document.getElementById('mapButton');
    const playButton = document.getElementById('playButton');
    const sighhhDisplay = document.getElementById('sighhh');
    const fleepMessage = document.getElementById('fleepMessage');
    const blackOverlay = document.getElementById('blackOverlay');

    const borderWidth = 2;
    const defaultRadius = 30;
    const initialRadius = 60;
    const resizeHoldThreshold = 200;

    const circle = {
        x: 0,
        y: 0,
        radius: initialRadius,
        dx: 0,
        dy: 0,
        isDragging: false,
        dragTouchId: null,
        wasDraggingWhenPaused: false,
        lastX: 0,
        lastY: 0,
        lastTime: 0,
        wallContact: {
            left: { time: 0, inContact: false },
            right: { time: 0, inContact: false },
            top: { time: 0, inContact: false },
            bottom: { time: 0, inContact: false },
            boundary: { time: 0, inContact: false }
        },
        resizeTouchId: null,
        isResizing: false,
        resizeStartX: 0,
        resizeStartY: 0,
        initialRadius: initialRadius,
        resizeStartTime: 0,
        resizeTimer: null
    };

    const gravity = 0.5;
    const friction = 0.98;
    const bounciness = 0.9;
    const bounceTimeWindow = 100;

    const colors = [
        { r: 0, g: 0, b: 0 },
        { r: 5, g: 5, b: 25 },
        { r: 15, g: 5, b: 25 }
    ];
    let currentColorIndex = 0;
    let colorProgress = 0;
    const colorTransitionSpeed = 0.01;

    let isCountingDown = false;
    let countdown = 3;
    let countdownInterval = null;
    let countdownOpacity = 0;
    let wallHits = 0;
    let level = 1;
    let isTrackingHits = false;
    let lives = 3;
    let hiScore = 0;
    let isPaused = false;
    let isFleepSequence = false;

    let previousLives = lives;
    let previousLevel = level;
    let previousHiScore = hiScore;

    let currentMode = 'survival';
    let currentMap = 'rectangle';

    const trail = [];
    const maxTrailLength = 20;
    const trailFadeRate = 0.1;

    let shownTexts = new Set();
    let currentSighhhText = '';
    let sighhhVisible = false;
    let sighhhTimer = null;

    let holdTimers = { play: null, mode: null, map: null };
    let buttonActivated = { play: false, mode: false, map: false };

    const gameStates = {
        'survival-rectangle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
        'endurance-rectangle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
        'survival-circle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
        'endurance-circle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false }
    };

    function setCanvasSize() {
        const wallHitsTop = parseInt(window.getComputedStyle(levelContainer).top) || 40;
        const wallHitsHeight = levelContainer.offsetHeight || 60;
        const wallHitsBottom = wallHitsTop + wallHitsHeight;
        const buttonHeight = modeButton.offsetHeight || 36;
        const canvasShrink = 10;
        const snugGap = 5;

        const availableHeight = window.innerHeight - wallHitsBottom - canvasShrink - buttonHeight - snugGap;
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.style.width = `${window.innerWidth * 0.9}px`;
        canvas.style.height = `${availableHeight - 2 * borderWidth}px`;
        canvas.width = window.innerWidth * 0.9 * pixelRatio;
        canvas.height = (availableHeight - 2 * borderWidth) * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);

        const canvasLeft = (window.innerWidth - (window.innerWidth * 0.9)) / 2;
        const canvasTop = wallHitsBottom + snugGap;
        canvas.style.top = `${canvasTop}px`;
        canvas.style.left = `${canvasLeft}px`;

        const canvasBottom = canvasTop + (availableHeight - 2 * borderWidth);
        const canvasHeight = availableHeight - 2 * borderWidth;
        const countdownTop = canvasTop + (canvasHeight * 1 / 6);
        countdownDisplay.style.top = `${countdownTop}px`;

        const buttonTop = canvasBottom + snugGap;
        modeButton.style.top = `${buttonTop}px`;
        modeButton.style.bottom = '';
        modeButton.style.left = `${canvasLeft}px`;

        mapButton.style.top = `${buttonTop}px`;
        mapButton.style.bottom = '';
        mapButton.style.right = `${window.innerWidth - (canvasLeft + (window.innerWidth * 0.9))}px`;

        playButton.style.top = `${buttonTop}px`;
        playButton.style.bottom = '';

        livesCount.style.left = `${canvasLeft}px`;
        hiScoreCount.style.right = `${window.innerWidth - (canvasLeft + (window.innerWidth * 0.9))}px`;

        sighhhDisplay.style.top = `${wallHitsBottom + 10}px`;

        constrainCircle();
    }

    document.addEventListener('DOMContentLoaded', () => {
        setCanvasSize();
        requestAnimationFrame(() => setCanvasSize());
    });
    window.addEventListener('resize', setCanvasSize);

    function updateDisplay() {
        if (lives !== previousLives) {
            if (lives > previousLives) {
                livesCount.classList.remove('flash-green', 'flash-red');
                void livesCount.offsetHeight;
                livesCount.classList.add('flash-green');
            } else if (lives < previousLives) {
                livesCount.classList.remove('flash-green', 'flash-red');
                void livesCount.offsetHeight;
                livesCount.classList.add('flash-red');
            }
            previousLives = lives;
        }

        if (level !== previousLevel) {
            if (level < previousLevel) {
                levelNumber.classList.remove('flash-red', 'flash-white');
                void levelNumber.offsetHeight;
                levelNumber.classList.add('flash-red');
            } else if (level > previousLevel) {
                levelNumber.classList.remove('flash-red', 'flash-white');
                void levelNumber.offsetHeight;
                levelNumber.classList.add('flash-white');
            }
            previousLevel = level;
        }

        if (hiScore !== previousHiScore) {
            if (hiScore > previousHiScore) {
                hiScoreCount.classList.remove('flash-green');
                void hiScoreCount.offsetHeight;
                hiScoreCount.classList.add('flash-green');
            }
            previousHiScore = hiScore;
        }

        levelNumber.textContent = `${level}`;
        livesCount.textContent = lives === Infinity ? 'âˆž' : lives;
        hiScoreCount.textContent = hiScore;
        titleDisplay.textContent = currentMode === 'survival' ? 'Survival Mode' : 'Endurance Mode';
        setCanvasSize();

        playButton.textContent = isPaused ? 'RESUME' : 'PAUSE';
        countdownDisplay.style.opacity = countdownOpacity;
        countdownDisplay.textContent = countdown;

        sighhhDisplay.innerHTML = currentSighhhText === 'SIGHHH me to FLEEP' 
            ? 'SIGHHH me to <span id="fleepSpan">FLEEP</span>' 
            : currentSighhhText;
        sighhhDisplay.style.visibility = sighhhVisible ? 'visible' : 'hidden';
        sighhhDisplay.classList.toggle('yee-haw', currentSighhhText === 'yee haw BII');

        const fleepSpan = document.getElementById('fleepSpan');
        if (fleepSpan && !fleepSpan.onclick) {
            fleepSpan.onclick = triggerFleepSequence;
        }

        wallHitsDisplay.textContent = `${wallHits}`;
    }

    function showText(text) {
        if (!shownTexts.has(text)) {
            shownTexts.add(text);
            currentSighhhText = text;
            sighhhVisible = true;
            updateDisplay();
            if (sighhhTimer) clearTimeout(sighhhTimer);
            sighhhTimer = setTimeout(() => {
                sighhhVisible = false;
                updateDisplay();
            }, 2000);
        }
    }

    function triggerFleepSequence() {
        if (isFleepSequence) return;
        isFleepSequence = true;

        const savedState = {
            circleDx: circle.dx,
            circleDy: circle.dy,
            colorProgress: colorProgress,
            countdownInterval: countdownInterval,
            sighhhTimer: sighhhTimer,
            sighhhTimerStart: sighhhTimer ? Date.now() : null
        };

        if (countdownInterval) clearInterval(countdownInterval);
        if (sighhhTimer) clearTimeout(sighhhTimer);
        circle.dx = 0;
        circle.dy = 0;

        blackOverlay.style.transition = 'background 1s ease';
        blackOverlay.style.background = 'rgba(0, 0, 0, 1)';
        
        setTimeout(() => {
            fleepMessage.style.transition = 'opacity 1s ease';
            fleepMessage.style.opacity = '1';
            
            setTimeout(() => {
                setTimeout(() => {
                    fleepMessage.style.opacity = '0';
                    
                    setTimeout(() => {
                        blackOverlay.style.background = 'rgba(0, 0, 0, 0)';
                        
                        setTimeout(() => {
                            circle.dx = savedState.circleDx;
                            circle.dy = savedState.circleDy;
                            colorProgress = savedState.colorProgress;
                            if (savedState.countdownInterval) {
                                countdownInterval = setInterval(() => {
                                    countdown--;
                                    if (countdown > 0) {
                                        countdownDisplay.textContent = countdown;
                                    } else {
                                        countdownOpacity = 0;
                                        countdownDisplay.style.opacity = countdownOpacity;
                                        clearInterval(countdownInterval);
                                        countdownInterval = null;
                                        isCountingDown = false;
                                        updateDisplay();
                                    }
                                }, 1000);
                            }
                            if (savedState.sighhhTimer) {
                                const elapsed = Date.now() - savedState.sighhhTimerStart;
                                const remaining = Math.max(2000 - elapsed, 0);
                                sighhhTimer = setTimeout(() => {
                                    sighhhVisible = false;
                                    updateDisplay();
                                }, remaining);
                            }
                            isFleepSequence = false;
                            blackOverlay.style.transition = '';
                            fleepMessage.style.transition = '';
                        }, 1000);
                    }, 1000);
                }, 1000);
            }, 1000);
        }, 1000);
    }

    function constrainCircle() {
        if (currentMap === 'rectangle') {
            circle.x = Math.max(circle.radius, Math.min(canvas.width / (window.devicePixelRatio || 1) - circle.radius, circle.x));
            circle.y = Math.max(circle.radius, Math.min(canvas.height / (window.devicePixelRatio || 1) - circle.radius, circle.y));
        }intern else {
            const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
            const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
            const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
            if (distFromCenter + circle.radius > maxRadius) {
                const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                circle.x = centerX + Math.cos(angle) * (maxRadius - circle.radius);
                circle.y = centerY + Math.sin(angle) * (maxRadius - circle.radius);
            }
        }
    }

    function saveState() {
        const key = `${currentMode}-${currentMap}`;
        gameStates[key] = {
            level,
            lives,
            hiScore,
            circle: {
                x: circle.x,
                y: circle.y,
                radius: circle.radius,
                dx: circle.dx,
                dy: circle.dy,
                isDragging: circle.isDragging,
                dragTouchId: circle.dragTouchId,
                lastX: circle.lastX,
                lastY: circle.lastY,
                lastTime: circle.lastTime,
                wasDraggingWhenPaused: circle.wasDraggingWhenPaused
            },
            trail: [...trail],
            wallHits,
            isTrackingHits,
            isPaused,
            isCountingDown,
            countdown,
            countdownOpacity,
            wasDraggingWhenPaused: circle.wasDraggingWhenPaused
        };
        if (isCountingDown) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
    }

    function loadState(mode, map) {
        const key = `${mode}-${map}`;
        const state = gameStates[key];
        level = state.level;
        lives = state.lives;
        hiScore = state.hiScore;
        wallHits = state.wallHits;
        isTrackingHits = state.isTrackingHits;
        isPaused = state.isPaused;
        isCountingDown = state.isCountingDown;
        countdown = state.countdown;
        countdownOpacity = state.countdownOpacity;
        circle.wasDraggingWhenPaused = state.wasDraggingWhenPaused;

        if (state.circle.x !== undefined) {
            circle.x = state.circle.x;
            circle.y = state.circle.y;
            circle.radius = state.circle.radius || initialRadius;
            circle.dx = state.circle.dx;
            circle.dy = state.circle.dy;
            circle.isDragging = state.isDragging;
            circle.dragTouchId = state.dragTouchId;
            circle.lastX = state.lastX;
            circle.lastY = state.lastY;
            circle.lastTime = state.lastTime || Date.now();
        } else {
            circle.x = (canvas.width / (window.devicePixelRatio || 1)) / 2;
            circle.y = (canvas.height / (window.devicePixelRatio || 1)) / 2;
            circle.radius = initialRadius;
            circle.dx = 0;
            circle.dy = 0;
            circle.isDragging = false;
            circle.dragTouchId = null;
            circle.lastX = circle.x;
            circle.lastY = circle.y;
            circle.lastTime = Date.now();
        }

        constrainCircle();
        trail.length = 0;
        if (state.trail && state.trail.length > 0) {
            trail.push(...state.trail);
        }

        updateDisplay();
        requestAnimationFrame(() => drawScene(updateColors()));
    }

    function invertColor(rgb) {
        return { r: 255 - rgb.r, g: 255 - rgb.g, b: 255 - rgb.b };
    }

    function updateColors() {
        const currentColor = colors[currentColorIndex];
        const nextColorIndex = (currentColorIndex + 1) % colors.length;
        const nextColor = colors[nextColorIndex];

        const r = Math.round(currentColor.r + (nextColor.r - currentColor.r) * colorProgress);
        const g = Math.round(currentColor.g + (nextColor.g - currentColor.g) * colorProgress);
        const b = Math.round(currentColor.b + (nextColor.b - currentColor.b) * colorProgress);

        document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

        const textColor = `rgb(${r}, ${g}, ${b})`;
        modeButton.style.color = textColor;
        mapButton.style.color = textColor;
        playButton.style.color = textColor;

        const invertedColor = invertColor({ r, g, b });
        const invertedStyle = `rgb(${invertedColor.r}, ${invertedColor.g}, ${invertedColor.b})`;
        modeButton.style.backgroundColor = invertedStyle;
        mapButton.style.backgroundColor = invertedStyle;
        playButton.style.backgroundColor = invertedStyle;

        countdownDisplay.style.color = invertedStyle;
        countdownDisplay.style.textShadow = `0 0 10px rgb(${r}, ${g}, ${b})`;

        if (!isFleepSequence) {
            colorProgress += colorTransitionSpeed;
            if (colorProgress >= 1) {
                colorProgress = 0;
                currentColorIndex = (currentColorIndex + 1) % colors.length;
            }
        }

        return { r, g, b, inverted: invertedColor };
    }

    function getCircleColor(counterColor) {
        if (counterColor === 'rgb(11, 74, 28)') return 'rgb(11, 74, 28)';
        if (counterColor === 'rgb(130, 33, 33)') return 'rgb(130, 33, 33)';
        return null;
    }

    function lightenColor(color) {
        if (color === 'rgb(11, 74, 28)') return 'rgba(11, 74, 28,';
        if (color === 'rgb(130, 33, 33)') return 'rgba(130, 33, 33,';
        const [r, g, b] = color.match(/\d+/g).map(Number);
        return `rgba(${Math.min(r + 100, 255)}, ${Math.min(g + 100, 255)}, ${Math.min(b + 100, 255)},`;
    }

    function drawScene(color) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = `rgb(${color.inverted.r}, ${color.inverted.g}, ${color.inverted.b})`;
        ctx.lineWidth = borderWidth * 2;
        if (currentMap === 'rectangle') {
            ctx.strokeRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
        } else {
            ctx.beginPath();
            ctx.arc((canvas.width / (window.devicePixelRatio || 1)) / 2, (canvas.height / (window.devicePixelRatio || 1)) / 2, Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth, 0, Math.PI * 2);
            ctx.stroke();
        }

        const greenColor = 'rgb(11, 74, 28)';
        let counterColor = '#e0e0e0';
        if (wallHits === level) counterColor = greenColor;
        else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';

        const circleColor = getCircleColor(counterColor) || `rgb(${color.inverted.r}, ${color.inverted.g}, ${color.inverted.b})`;
        const trailBaseColor = lightenColor(circleColor);

        if (trail.length > 1) {
            ctx.beginPath();
            ctx.lineWidth = circle.radius * 2;
            ctx.lineCap = 'round';
            for (let i = 0; i < trail.length - 1; i++) {
                const start = trail[i];
                const end = trail[i + 1];
                const opacity = start.opacity * (1 - (i / trail.length));
                ctx.strokeStyle = `${trailBaseColor} ${opacity})`;
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
        }

        ctx.beginPath();
        const pixelRatio = window.devicePixelRatio || 1;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
        ctx.fillStyle = circleColor;
        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0;

        const shouldShowHoldingText = (!isPaused && circle.isDragging) || (isPaused && circle.wasDraggingWhenPaused);
        if (shouldShowHoldingText) {
            const text = "HOLDING";
            const fontSize = 24;
            const textRadius = circle.radius + 60;
            const totalLetters = text.length * 4;
            const anglePerLetter = (2 * Math.PI) / totalLetters;

            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = `rgb(${color.inverted.r}, ${color.inverted.g}, ${color.inverted.b})`;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 5 * pixelRatio;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            const startAngles = [
                -Math.PI / 2,
                0,
                Math.PI / 2,
                Math.PI
            ];

            for (let instance = 0; instance < 4; instance++) {
                const startAngle = startAngles[instance];
                for (let i = 0; i < text.length; i++) {
                    const angle = startAngle + (i * anglePerLetter);
                    const x = circle.x + textRadius * Math.cos(angle);
                    const y = circle.y + textRadius * Math.sin(angle);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.fillText(text[i], 0, 0);
                    ctx.restore();
                }
            }
            ctx.shadowBlur = 0;
        }

        const offset = circle.radius + 30;

        ctx.font = 'bold 40px Impact, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = counterColor;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        if (counterColor === 'rgb(11, 74, 28)') {
            ctx.shadowColor = 'rgb(50, 200, 100)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(wallHits, circle.x, circle.y - offset);
            ctx.fillText(wallHits, circle.x, circle.y + offset);
            ctx.fillText(wallHits, circle.x - offset, circle.y);
            ctx.fillText(wallHits, circle.x + offset, circle.y);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
        } else if (counterColor === 'rgb(130, 33, 33)') {
            ctx.shadowColor = 'rgb(255, 80, 80)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(wallHits, circle.x, circle.y - offset);
            ctx.fillText(wallHits, circle.x, circle.y + offset);
            ctx.fillText(wallHits, circle.x - offset, circle.y);
            ctx.fillText(wallHits, circle.x + offset, circle.y);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
        }
        ctx.fillText(wallHits, circle.x, circle.y - offset);
        ctx.fillText(wallHits, circle.x, circle.y + offset);
        ctx.fillText(wallHits, circle.x - offset, circle.y);
        ctx.fillText(wallHits, circle.x + offset, circle.y);

        ctx.fillStyle = greenColor;
        ctx.shadowColor = 'rgb(50, 200, 100)';
        ctx.shadowBlur = 2 * pixelRatio;
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10 * pixelRatio;
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
        ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);

        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }

    function updatePhysics() {
        if (isPaused || isFleepSequence) {
            if (circle.isDragging) {
                circle.dx = 0;
                circle.dy = 0;
            }
            return;
        }

        const currentTime = Date.now();

        if (!circle.isDragging) {
            circle.dy += gravity;
            circle.x += circle.dx;
            circle.y += circle.dy;
            circle.dx *= friction;
            circle.dy *= friction;

            const velocity = Math.sqrt(circle.dx * circle.dx + circle.dy * circle.dy);
            const trailLength = Math.min(maxTrailLength, Math.floor(velocity / 10));
            trail.unshift({ x: circle.x, y: circle.y, opacity: 1 });
            while (trail.length > trailLength) trail.pop();
            for (let i = 0; i < trail.length; i++) {
                trail[i].opacity -= trailFadeRate;
                if (trail[i].opacity <= 0) trail.splice(i, 1);
            }

            let walls;
            if (currentMap === 'rectangle') {
                walls = [
                    { name: 'right', edge: canvas.width / (window.devicePixelRatio || 1), pos: circle.x + circle.radius, velocity: circle.dx, isContact: circle.x + circle.radius >= canvas.width / (window.devicePixelRatio || 1) },
                    { name: 'left', edge: 0, pos: circle.x - circle.radius, velocity: circle.dx, isContact: circle.x - circle.radius <= 0 },
                    { name: 'bottom', edge: canvas.height / (window.devicePixelRatio || 1), pos: circle.y + circle.radius, velocity: circle.dy, isContact: circle.y + circle.radius >= canvas.height / (window.devicePixelRatio || 1) },
                    { name: 'top', edge: 0, pos: circle.y - circle.radius, velocity: circle.dy, isContact: circle.y - circle.radius <= 0 }
                ];
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                const isContact = distFromCenter + circle.radius >= radius;
                walls = [{ name: 'boundary', edge: radius, pos: distFromCenter + circle.radius, velocity: 0, isContact }];
            }

            walls.forEach(wall => {
                const contact = circle.wallContact[wall.name];
                if (wall.isContact) {
                    if (!contact.inContact) {
                        contact.inContact = true;
                        contact.time = currentTime;
                        if (isTrackingHits) {
                            wallHits++;
                            wallHitsDisplay.textContent = `${wallHits}`;
                            const greenColor = 'rgb(11, 74, 28)';
                            let counterColor = '#e0e0e0';
                            if (wallHits === level) counterColor = greenColor;
                            else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';
                            wallHitsDisplay.style.color = counterColor;
                            if (counterColor === '#e0e0e0') {
                                wallHitsDisplay.classList.remove('bright-glow');
                                wallHitsDisplay.style.textShadow = '0 0 5px #fff';
                            } else {
                                wallHitsDisplay.classList.add('bright-glow');
                                const outlineColor = counterColor === greenColor ? 'rgb(50, 200, 100)' : 'rgb(255, 80, 80)';
                                wallHitsDisplay.style.setProperty('--outline-color', outlineColor);
                                wallHitsDisplay.style.textShadow = `0 0 10px #fff, 0 0 2px ${outlineColor}`;
                            }
                            // Check lives immediately in survival mode
                            if (currentMode === 'survival' && wallHits > level && lives > 0) {
                                lives--;
                                let text = '';
                                if (lives === 2) text = 'sighhh';
                                else if (lives === 1) text = 'SighhhAFF';
                                else if (lives <= 0) {
                                    text = 'SIGHHH me to FLEEP';
                                    level = 1;
                                    lives = 3;
                                    wallHits = 0;
                                    isTrackingHits = false;
                                    startCountdown();
                                }
                                if (text) showText(text);
                                updateDisplay();
                            }
                        }
                    }
                } else {
                    if (contact.inContact) {
                        contact.inContact = false;
                    }
                }
            });

            if (currentMap === 'rectangle') {
                if (circle.x + circle.radius > canvas.width / (window.devicePixelRatio || 1)) {
                    circle.x = (canvas.width / (window.devicePixelRatio || 1)) - circle.radius;
                    circle.dx = -circle.dx * bounciness;
                } else if (circle.x - circle.radius < 0) {
                    circle.x = circle.radius;
                    circle.dx = -circle.dx * bounciness;
                }
                if (circle.y + circle.radius > canvas.height / (window.devicePixelRatio || 1)) {
                    circle.y = (canvas.height / (window.devicePixelRatio || 1)) - circle.radius;
                    circle.dy = -circle.dy * bounciness;
                } else if (circle.y - circle.radius < 0) {
                    circle.y = circle.radius;
                    circle.dy = -circle.dy * bounciness;
                }
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                if (distFromCenter + circle.radius >= radius) {
                    const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                    circle.x = centerX + Math.cos(angle) * (radius - circle.radius);
                    circle.y = centerY + Math.sin(angle) * (radius - circle.radius);
                    const speed = Math.sqrt(circle.dx ** 2 + circle.dy ** 2);
                    circle.dx = -Math.cos(angle) * speed * bounciness;
                    circle.dy = -Math.sin(angle) * speed * bounciness;
                }
            }
        }
    }

    function startCountdown(isResuming = false) {
        if (!isResuming) {
            isCountingDown = true;
            countdown = 3;
            wallHits = 0;
            wallHitsDisplay.textContent = `${wallHits}`;
            wallHitsDisplay.style.color = '#e0e0e0';
            wallHitsDisplay.classList.remove('bright-glow');
            wallHitsDisplay.style.textShadow = '0 0 5px #fff';
            isTrackingHits = true;
            countdownOpacity = 1;
            shownTexts.clear();
            sighhhVisible = false;
        } else {
            isCountingDown = true;
        }
        countdownDisplay.style.opacity = countdownOpacity;
        countdownDisplay.textContent = countdown;

        if (countdownInterval) clearInterval(countdownInterval);
        countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                countdownDisplay.textContent = countdown;
            } else {
                countdownOpacity = 0;
                countdownDisplay.style.opacity = countdownOpacity;
                clearInterval(countdownInterval);
                countdownInterval = null;
                isCountingDown = false;
                updateDisplay();
            }
        }, 1000);
    }

    function getMousePos(e, touchId = null) {
        const rect = canvas.getBoundingClientRect();
        if (touchId !== null && e.touches) {
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === touchId) {
                    return {
                        x: e.touches[i].clientX - rect.left,
                        y: e.touches[i].clientY - rect.top
                    };
                }
            }
        }
        return {
            x: (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left,
            y: (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top
        };
    }

    function getScreenPos(e, touchId = null) {
        if (touchId !== null && (e.touches || e.changedTouches)) {
            const touches = e.changedTouches || e.touches;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === touchId) {
                    return {
                        x: touches[i].clientX,
                        y: touches[i].clientY
                    };
                }
            }
        }
        return {
            x: e.clientX || (e.touches && e.touches[0].clientX) || (e.changedTouches && e.changedTouches[0].clientX),
            y: e.clientY || (e.touches && e.touches[0].clientY) || (e.changedTouches && e.changedTouches[0].clientY)
        };
    }

    function handleCircleTap(e) {
        if (isPaused || isFleepSequence) return;
        const pos = getMousePos(e);
        const dist = Math.sqrt((pos.x - circle.x) ** 2 + (pos.y - circle.y) ** 2);
        if (dist < circle.radius && (!circle.isDragging || e.touches.length === 1)) {
            console.log('Circle tapped');
            e.preventDefault();
            if (isTrackingHits) {
                if (isCountingDown) {
                    if (wallHits === level) {
                        isTrackingHits = false;
                        isCountingDown = false;
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        countdownOpacity = 0;
                        countdownDisplay.style.opacity = countdownOpacity;
                        const completedLevel = level;
                        level++;
                        if (currentMode === 'survival') {
                            lives = 3;
                            showText('yee haw BII');
                        }
                        if (completedLevel > hiScore) hiScore = completedLevel;
                        wallHits = 0;
                        saveState();
                        updateDisplay();
                        startCountdown();
                    }
                } else {
                    isTrackingHits = false;
                    if (wallHits === level) {
                        const completedLevel = level;
                        level++;
                        if (currentMode === 'survival') {
                            lives = 3;
                            showText('yee haw BII');
                        }
                        if (completedLevel > hiScore) hiScore = completedLevel;
                        wallHits = 0;
                    }
                    // Lives are now handled in updatePhysics, so we don't adjust them here
                    saveState();
                    updateDisplay();
                    startCountdown();
                }
            } else if (!isCountingDown) {
                wallHits = 0;
                startCountdown();
            }
        }
    }

    function startDragging(e) {
        if (isFleepSequence || (isPaused && !circle.wasDraggingWhenPaused)) return;
        const pos = getMousePos(e, e.touches ? e.touches[0].identifier : null);
        const dist = Math.sqrt((pos.x - circle.x) ** 2 + (pos.y - circle.y) ** 2);
        if (dist < circle.radius) {
            e.preventDefault();
            circle.isDragging = true;
            circle.dragTouchId = e.touches ? e.touches[0].identifier : null;
            circle.lastX = pos.x;
            circle.lastY = pos.y;
            circle.lastTime = Date.now();
            circle.dx = 0;
            circle.dy = 0;
            if (!isPaused) trail.length = 0;
            buttonActivated = { play: false, mode: false, map: false };
            console.log('Dragging started, touchId:', circle.dragTouchId);
        }
    }

    function startResizing(e) {
        if (!circle.isDragging || circle.isResizing || isFleepSequence || e.touches.length < 2) return;
        if (isPaused && !circle.wasDraggingWhenPaused) return;

        const dragTouchIndex = Array.from(e.touches).findIndex(t => t.identifier === circle.dragTouchId);
        if (dragTouchIndex === -1) return;

        const otherTouch = e.touches[dragTouchIndex === 0 ? 1 : 0];
        const pos = getMousePos(e, otherTouch.identifier);
        const canvasRect = canvas.getBoundingClientRect();
        const isOverCanvas = (
            otherTouch.clientX >= canvasRect.left &&
            otherTouch.clientX <= canvasRect.right &&
            otherTouch.clientY >= canvasRect.top &&
            otherTouch.clientY <= canvasRect.bottom
        );

        if (isOverCanvas) {
            circle.resizeTouchId = otherTouch.identifier;
            circle.resizeStartX = pos.x;
            circle.resizeStartY = pos.y;
            circle.initialRadius = circle.radius;
            circle.resizeStartTime = Date.now();
            circle.resizeTimer = setTimeout(() => {
                if (circle.resizeTouchId !== null) {
                    circle.isResizing = true;
                    console.log('Resizing started, resizeTouchId:', circle.resizeTouchId);
                }
            }, resizeHoldThreshold);
            console.log('Resize touch initiated, waiting for hold threshold');
        }
    }

    function drag(e) {
        if (isFleepSequence) return;

        if (circle.isDragging && !circle.isResizing) {
            const pos = getMousePos(e, circle.dragTouchId);

            if (currentMap === 'rectangle') {
                pos.x = Math.max(circle.radius, Math.min((canvas.width / (window.devicePixelRatio || 1)) - circle.radius, pos.x));
                pos.y = Math.max(circle.radius, Math.min((canvas.height / (window.devicePixelRatio || 1)) - circle.radius, pos.y));
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth - circle.radius;
                const dx = pos.x - centerX;
                const dy = pos.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > maxRadius) {
                    const angle = Math.atan2(dy, dx);
                    pos.x = centerX + Math.cos(angle) * maxRadius;
                    pos.y = centerY + Math.sin(angle) * maxRadius;
                }
            }

            circle.x = pos.x;
            circle.y = pos.y;

            if (!isPaused) {
                const currentTime = Date.now();
                const dt = (currentTime - circle.lastTime) / 1000;
                if (dt > 0) {
                    circle.dx = (pos.x - circle.lastX) / dt;
                    circle.dy = (pos.y - circle.lastY) / dt;
                }
                circle.lastTime = currentTime;
            }
            circle.lastX = pos.x;
            circle.lastY = pos.y;
        }

        if (circle.isResizing) {
            const resizePos = getMousePos(e, circle.resizeTouchId);
            const dx = resizePos.x - circle.x;
            const dy = resizePos.y - circle.y;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            const initialDistance = Math.sqrt(
                (circle.resizeStartX - circle.x) ** 2 + 
                (circle.resizeStartY - circle.y) ** 2
            );
            const distanceDelta = currentDistance - initialDistance;

            const newRadius = Math.max(defaultRadius, circle.initialRadius + distanceDelta / 2);
            let maxAllowedRadius;

            if (currentMap === 'rectangle') {
                maxAllowedRadius = Math.min(
                    circle.x, 
                    (canvas.width / (window.devicePixelRatio || 1)) - circle.x,
                    circle.y,
                    (canvas.height / (window.devicePixelRatio || 1)) - circle.y
                );
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const distToCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                maxAllowedRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth - distToCenter;
            }

            circle.radius = Math.min(newRadius, maxAllowedRadius);
        }

        const screenPos = getScreenPos(e, circle.dragTouchId);
        const target = document.elementFromPoint(screenPos.x, screenPos.y);

        if (target === playButton) {
            if (!holdTimers.play && !buttonActivated.play) {
                playButton.classList.remove('glow-green', 'glow-red', 'recede');
                playButton.classList.add(isPaused ? 'glow-green' : 'glow-red');
                holdTimers.play = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === playButton) {
                        playButton.classList.remove('glow-green', 'glow-red');
                        playButton.classList.add('recede');
                        if (isPaused) {
                            isPaused = false;
                            circle.lastX = getMousePos(e, circle.dragTouchId).x;
                            circle.lastY = getMousePos(e, circle.dragTouchId).y;
                            circle.lastTime = Date.now();
                            circle.dx = 0;
                            circle.dy = 0;
                            if (gameStates[`${currentMode}-${currentMap}`].isCountingDown) startCountdown(true);
                        } else {
                            circle.wasDraggingWhenPaused = circle.isDragging;
                            isPaused = true;
                            saveState();
                        }
                        updateDisplay();
                        buttonActivated.play = true;
                    }
                    holdTimers.play = null;
                }, 1000);
            }
        } else {
            if (holdTimers.play) {
                clearTimeout(holdTimers.play);
                holdTimers.play = null;
                playButton.classList.remove('glow-green', 'glow-red');
                playButton.classList.add('recede');
            }
            if (buttonActivated.play && target !== playButton) buttonActivated.play = false;
        }

        if (target === modeButton) {
            if (!holdTimers.mode && !buttonActivated.mode) {
                modeButton.classList.remove('glow-white', 'recede');
                modeButton.classList.add('glow-white');
                holdTimers.mode = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === modeButton) {
                        modeButton.classList.remove('glow-white');
                        modeButton.classList.add('recede');
                        if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
                        isPaused = true;
                        saveState();
                        currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
                        sighhhVisible = false;
                        if (sighhhTimer) clearTimeout(sighhhTimer);
                        shownTexts.clear();
                        loadState(currentMode, currentMap);
                        updateDisplay();
                        buttonActivated.mode = true;
                    }
                    holdTimers.mode = null;
                }, 1000);
            }
        } else {
            if (holdTimers.mode) {
                clearTimeout(holdTimers.mode);
                holdTimers.mode = null;
                modeButton.classList.remove('glow-white');
                modeButton.classList.add('recede');
            }
            if (buttonActivated.mode && target !== modeButton) buttonActivated.mode = false;
        }

        if (target === mapButton) {
            if (!holdTimers.map && !buttonActivated.map) {
                mapButton.classList.remove('glow-white', 'recede');
                mapButton.classList.add('glow-white');
                holdTimers.map = setTimeout(() => {
                    if (circle.isDragging && document.elementFromPoint(screenPos.x, screenPos.y) === mapButton) {
                        mapButton.classList.remove('glow-white');
                        mapButton.classList.add('recede');
                        if (!isPaused) circle.wasDraggingWhenPaused = circle.isDragging;
                        isPaused = true;
                        saveState();
                        currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
                        sighhhVisible = false;
                        if (sighhhTimer) clearTimeout(sighhhTimer);
                        shownTexts.clear();
                        loadState(currentMode, currentMap);
                        updateDisplay();
                        buttonActivated.map = true;
                    }
                    holdTimers.map = null;
                }, 1000);
            }
        } else {
            if (holdTimers.map) {
                clearTimeout(holdTimers.map);
                holdTimers.map = null;
                mapButton.classList.remove('glow-white');
                mapButton.classList.add('recede');
            }
            if (buttonActivated.map && target !== mapButton) buttonActivated.map = false;
        }

        if (isPaused) saveState();
    }

    function stopDragging(e) {
        if (!circle.isDragging || isFleepSequence) return;
        let touchId = circle.dragTouchId;
        if (e.touches && e.touches.length > 0) return;
        if (e.changedTouches) {
            let matched = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    matched = true;
                    break;
                }
            }
            if (!matched) return;
        }

        const screenPos = getScreenPos(e, touchId);
        const target = document.elementFromPoint(screenPos.x, screenPos.y);
        const canvasRect = canvas.getBoundingClientRect();
        const isOverCanvas = (
            screenPos.x >= canvasRect.left &&
            screenPos.x <= canvasRect.right &&
            screenPos.y >= canvasRect.top &&
            screenPos.y <= canvasRect.bottom
        );

        console.log('Stop dragging, target:', target.id, 'isOverCanvas:', isOverCanvas, 'isPaused:', isPaused);

        if (target === playButton && !buttonActivated.play) {
            target.click();
        } else if (target === modeButton && !buttonActivated.mode) {
            modeButton.classList.remove('glow-white');
            modeButton.classList.add('recede');
            target.click();
        } else if (target === mapButton && !buttonActivated.map) {
            mapButton.classList.remove('glow-white');
            mapButton.classList.add('recede');
            target.click();
        }

        circle.isDragging = false;
        circle.dragTouchId = null;
        Object.keys(holdTimers).forEach(key => {
            if (holdTimers[key]) {
                clearTimeout(holdTimers[key]);
                holdTimers[key] = null;
                if (key === 'play') {
                    playButton.classList.remove('glow-green', 'glow-red');
                    playButton.classList.add('recede');
                } else {
                    document.getElementById(key).classList.remove('glow-white');
                    document.getElementById(key).classList.add('recede');
                }
            }
        });
        if (target !== playButton) buttonActivated.play = false;
        if (target !== modeButton) buttonActivated.mode = false;
        if (target !== mapButton) buttonActivated.map = false;

        if (!circle.isDragging && isPaused) saveState();
    }

    function stopResizing(e) {
        if (circle.resizeTouchId === null || isFleepSequence) return;
        if (e.touches && e.touches.length > 1) return;
        if (e.changedTouches) {
            let matched = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === circle.resizeTouchId) {
                    matched = true;
                    break;
                }
            }
            if (!matched) return;
        }

        const elapsed = Date.now() - circle.resizeStartTime;
        if (!circle.isResizing && elapsed < resizeHoldThreshold && !isPaused) {
            console.log('Quick tap detected, dropping circle');
            circle.isDragging = false;
            circle.dragTouchId = null;
            circle.dx = 0;
            circle.dy = 0;
        } else if (circle.isResizing) {
            console.log('Resizing stopped, new radius:', circle.radius);
            circle.isResizing = false;
        }

        if (circle.resizeTimer) {
            clearTimeout(circle.resizeTimer);
            circle.resizeTimer = null;
        }
        circle.resizeTouchId = null;
        constrainCircle();
        if (isPaused) saveState();
    }

    function handleMultiTouch(e) {
        if (isFleepSequence || e.touches.length < 2) return;
        const dragTouchIndex = Array.from(e.touches).findIndex(t => t.identifier === circle.dragTouchId);
        if (dragTouchIndex === -1) return;

        const otherTouch = e.touches[dragTouchIndex === 0 ? 1 : 0];
        const screenPos = { x: otherTouch.clientX, y: otherTouch.clientY };
        const canvasRect = canvas.getBoundingClientRect();
        const isOverCanvas = (
            screenPos.x >= canvasRect.left &&
            screenPos.x <= canvasRect.right &&
            screenPos.y >= canvasRect.top &&
            screenPos.y <= canvasRect.bottom
        );

        if (isOverCanvas && !circle.isResizing && !isPaused) {
            handleCircleTap({ touches: [otherTouch] });
        }
    }

    modeButton.addEventListener('click', () => {
        if (isFleepSequence) return;
        console.log('MODE button clicked');
        if (!isPaused) {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
        }
        saveState();
        currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
        sighhhVisible = false;
        if (sighhhTimer) clearTimeout(sighhhTimer);
        shownTexts.clear();
        loadState(currentMode, currentMap);
        updateDisplay();
    });

    mapButton.addEventListener('click', () => {
        if (isFleepSequence) return;
        console.log('MAP button clicked');
        if (!isPaused) {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
        }
        saveState();
        currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
        sighhhVisible = false;
        if (sighhhTimer) clearTimeout(sighhhTimer);
        shownTexts.clear();
        loadState(currentMode, currentMap);
        updateDisplay();
    });

    playButton.addEventListener('click', (e) => {
        if (isFleepSequence) return;
        console.log('PAUSE/RESUME button clicked');
        if (isPaused) {
            isPaused = false;
            if (circle.isDragging) {
                const pos = getMousePos(e);
                circle.lastX = pos.x;
                circle.lastY = pos.y;
                circle.lastTime = Date.now();
                circle.dx = 0;
                circle.dy = 0;
            } else if (circle.wasDraggingWhenPaused) {
                circle.isDragging = false;
                circle.dragTouchId = null;
                constrainCircle();
                circle.dx = 0;
                circle.dy = 0;
            } else {
                constrainCircle();
                circle.dx = circle.dx || 0;
                circle.dy = circle.dy || 0;
            }
            circle.wasDraggingWhenPaused = false;
            if (gameStates[`${currentMode}-${currentMap}`].isCountingDown) startCountdown(true);
            updateDisplay();
        } else {
            circle.wasDraggingWhenPaused = circle.isDragging;
            isPaused = true;
            saveState();
            updateDisplay();
        }
    });

    canvas.addEventListener('mousedown', startDragging);
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', stopDragging);
    canvas.addEventListener('click', handleCircleTap);

    canvas.addEventListener('touchstart', (e) => {
        startDragging(e);
        handleCircleTap(e);
        startResizing(e);
        handleMultiTouch(e);
    });
    canvas.addEventListener('touchmove', drag);
    canvas.addEventListener('touchend', (e) => {
        stopDragging(e);
        stopResizing(e);
    });

    document.addEventListener('mouseup', stopDragging);
    document.addEventListener('touchend', (e) => {
        stopDragging(e);
        stopResizing(e);
    });

    modeButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1 && !isFleepSequence) {
            console.log('MODE button tapped during drag');
            modeButton.click();
        }
    });

    mapButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1 && !isFleepSequence) {
            console.log('MAP button tapped during drag');
            mapButton.click();
        }
    });

    playButton.addEventListener('touchstart', (e) => {
        if (circle.isDragging && e.touches.length > 1 && !isFleepSequence) {
            console.log('PAUSE/RESUME button tapped during drag');
            playButton.click();
        }
    });

    function animate() {
        updatePhysics();
        const color = updateColors();
        drawScene(color);
        requestAnimationFrame(animate);
    }

    circle.x = window.innerWidth * 0.45;
    circle.y = window.innerHeight * 0.5;

    updateDisplay();
    animate();
</script>
