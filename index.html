<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throwable Bouncy Circle Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #000000;
            position: relative;
        }
        canvas {
            position: absolute;
            z-index: 5;
            background: transparent;
            pointer-events: auto;
        }
        #levelContainer, #countdown, #title {
            position: absolute;
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff;
            font-weight: bold;
            z-index: 2;
        }
        #title {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            white-space: nowrap;
        }
        #levelContainer {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            width: 120px;
            height: 60px;
            background: transparent;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
        }
        #levelContainer.flash-green {
            animation: flashGreenBorder 0.5s ease;
        }
        #levelContainer.flash-red {
            animation: flashRedBorder 0.5s ease;
        }
        #wallHits, #levelNumber {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Impact', sans-serif;
            font-size: 2.5em;
        }
        #wallHits {
            text-shadow: 0 0 5px #fff;
            border-right: 2px solid #e0e0e0;
        }
        #wallHits.bright-glow {
            text-shadow: 0 0 10px #fff, 0 0 2px var(--outline-color);
        }
        #levelNumber {
            color: rgb(11, 74, 28);
            text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100);
        }
        #levelNumber.flash-red {
            animation: flashRedLevel 0.5s ease;
        }
        #levelNumber.flash-white {
            animation: flashWhiteLevel 0.5s ease;
        }
        #countdown {
            left: 50%;
            transform: translateX(-50%);
            font-size: 4em;
            transition: opacity 0.5s ease;
            z-index: 10;
            pointer-events: none;
            color: #ffffff;
            text-shadow: 0 0 10px #000;
        }
        #livesCount, #hiScoreCount {
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff;
            font-size: 2.5em;
            position: absolute;
            z-index: 2;
            font-family: 'Impact', sans-serif;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            top: 40px;
        }
        #livesCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #livesCount.flash-red {
            animation: flashRed 0.5s ease;
        }
        #hiScoreCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #modeButton, #mapButton {
            position: absolute;
            z-index: 15;
        }
        #playButton {
            position: absolute;
            z-index: 20;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            font-size: 1em;
            display: block;
        }
        button {
            padding: 8px 16px;
            font-size: 1em;
            font-weight: bold;
            font-family: Arial, sans-serif;
            cursor: pointer;
            color: #ffffff;
            text-shadow: 0 0 5px #fff;
            background: transparent;
            border: 2px solid #ffffff;
            border-radius: 0;
            filter: drop-shadow(0 0 5px #fff);
            transition: none;
            z-index: 25;
            pointer-events: auto;
        }
        button:hover {
            filter: drop-shadow(0 0 5px #fff) brightness(85%);
        }
        #playButton.glow-green {
            animation: glowGreen 1s linear forwards;
        }
        #playButton.glow-red {
            animation: glowRed 1s linear forwards;
        }
        #modeButton.glow-white, #mapButton.glow-white {
            animation: glowWhite 1s linear forwards;
        }
        #playButton.recede, #modeButton.recede, #mapButton.recede {
            animation: recedeGlow 0.2s linear forwards;
        }
        #livesChange, #levelChange {
            position: absolute;
            z-index: 3;
            font-family: 'Impact', sans-serif;
            font-size: 0; /* Start at 0 size */
            top: 55px; /* Centered: 40px + 30px (half of 60px) - 15px (approx half of 1.5em) */
            pointer-events: none;
        }
        #livesChange {
            left: calc(60px + 10px); /* Right of livesCount with a 10px gap */
        }
        #levelChange {
            left: calc(50% + 60px + 10px); /* Right of levelContainer (120px wide, centered) */
        }
        #livesChange.plus, #levelChange.plus {
            color: rgb(11, 74, 28); /* Matching green from #levelNumber */
            animation: changePlus 1.25s ease forwards;
        }
        #livesChange.minus, #levelChange.minus {
            color: rgb(130, 33, 33); /* Matching red from flash animations */
            animation: changeMinus 1.25s ease forwards;
        }
        @keyframes glowGreen {
            0% { box-shadow: 0 0 5px rgb(11, 74, 28); }
            100% { box-shadow: 0 0 20px rgb(11, 74, 28); }
        }
        @keyframes glowRed {
            0% { box-shadow: 0 0 5px rgb(130, 33, 33); }
            100% { box-shadow: 0 0 20px rgb(130, 33, 33); }
        }
        @keyframes glowWhite {
            0% { box-shadow: 0 0 5px #ffffff; }
            100% { box-shadow: 0 0 20px #ffffff; }
        }
        @keyframes recedeGlow {
            0% { box-shadow: 0 0 20px; }
            100% { box-shadow: 0 0 0; }
        }
        @keyframes flashGreen {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
            50% { color: rgb(11, 74, 28); text-shadow: 0 0 5px #fff; border-color: rgb(11, 74, 28); }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
        }
        @keyframes flashRed {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 5px #fff; border-color: rgb(130, 33, 33); }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; border-color: #e0e0e0; }
        }
        @keyframes flashGreenBorder {
            0% { border-color: #e0e0e0; }
            50% { border-color: rgb(11, 74, 28); }
            100% { border-color: #e0e0e0; }
        }
        @keyframes flashRedBorder {
            0% { border-color: #e0e0e0; }
            50% { border-color: rgb(130, 33, 33); }
            100% { border-color: #e0e0e0; }
        }
        @keyframes flashRedLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        @keyframes flashWhiteLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: #e0e0e0; text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        @keyframes changePlus {
            0% { font-size: 0; transform: rotate(0deg); opacity: 1; } /* Start lower, no rotation */
            33% { font-size: 1.5em; transform: rotate(22.5deg); opacity: 1; } /* Grow up to center, rotate clockwise */
            66% { font-size: 1.5em; transform: rotate(22.5deg); opacity: 1; } /* Hold at center */
            100% { font-size: 0; transform: rotate(0deg); opacity: 0; } /* Shrink back to center, rotate counterclockwise */
        }
        @keyframes changeMinus {
            0% { font-size: 0; transform: rotate(0deg); opacity: 1; } /* Start lower, no rotation */
            33% { font-size: 1.5em; transform: rotate(22.5deg); opacity: 1; } /* Grow up to center, rotate clockwise */
            66% { font-size: 1.5em; transform: rotate(22.5deg); opacity: 1; } /* Hold at center */
            100% { font-size: 0; transform: rotate(0deg); opacity: 0; } /* Shrink back to center, rotate counterclockwise */
        }
        canvas.flash-green {
            animation: flashGreen 0.5s ease;
        }
        canvas.flash-red {
            animation: flashRed 0.5s ease;
        }
        .preview-rect {
            position: absolute;
            z-index: 4;
            pointer-events: none;
        }
        .preview-rect.glow {
            filter: drop-shadow(0 0 5px #fff);
        }
        .preview-rect.clickable {
            pointer-events: auto;
        }
        @keyframes sweepToLeft {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }
        @keyframes sweepToRight {
            0% { transform: translateX(0); }
            100% { transform: translateX(100%); }
        }
        @keyframes sweepFromLeft {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(0); }
        }
        @keyframes sweepFromRight {
            0% { transform: translateX(100%); }
            100% { transform: translateX(0); }
        }
        @keyframes sweepUpward {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes sweepRightward {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(100%); opacity: 0; }
        }
        @keyframes sweepLeftwardIn {
            0% { transform: translateX(-100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="title">SURVIVAL MODE</div>
    <div id="levelContainer">
        <div id="wallHits">0</div>
        <div id="levelNumber">1</div>
    </div>
    <div id="levelChange"></div>
    <div id="countdown" style="opacity: 0;"></div>
    <div id="livesCount">3</div>
    <div id="livesChange"></div>
    <div id="hiScoreCount">0</div>
    <button id="modeButton">MODE</button>
    <button id="mapButton">MAP</button>
    <canvas id="canvas"></canvas>
    <button id="playButton">PAUSE</button>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const levelContainer = document.getElementById('levelContainer');
        const levelNumber = document.getElementById('levelNumber');
        const levelChange = document.getElementById('levelChange');
        const countdownDisplay = document.getElementById('countdown');
        const wallHitsDisplay = document.getElementById('wallHits');
        const livesCount = document.getElementById('livesCount');
        const livesChange = document.getElementById('livesChange');
        const hiScoreCount = document.getElementById('hiScoreCount');
        const titleDisplay = document.getElementById('title');
        const modeButton = document.getElementById('modeButton');
        const mapButton = document.getElementById('mapButton');
        const playButton = document.getElementById('playButton');
        const borderWidth = 2;
        const defaultRadius = 30;
        const initialRadius = 60;
        const resizeHoldThreshold = 200;
        const circle = {
            x: 0,
            y: 0,
            radius: initialRadius,
            dx: 0,
            dy: 0,
            isDragging: false,
            dragTouchId: null,
            wasDraggingWhenPaused: false,
            lastX: 0,
            lastY: 0,
            lastTime: 0,
            wallContact: {
                left: { time: 0, inContact: false },
                right: { time: 0, inContact: false },
                top: { time: 0, inContact: false },
                bottom: { time: 0, inContact: false },
                boundary: { time: 0, inContact: false }
            },
            resizeTouchId: null,
            isResizing: false,
            resizeStartX: 0,
            resizeStartY: 0,
            initialRadius: initialRadius,
            resizeStartTime: 0,
            resizeTimer: null,
            hasBeenTouched: false
        };

        const gravity = 0.5;
        const friction = 0.98;
        const bounciness = 0.9;

        const targetThrowAt200 = 1;
        const throwGrowth = 1.01;
        const baseThrowMultiplier = targetThrowAt200 / Math.pow(throwGrowth, 199);
        let throwMultiplier = baseThrowMultiplier;

        let isCountingDown = false;
        let countdown = 3;
        let countdownInterval = null;
        let countdownOpacity = 0;
        let wallHits = 0;
        let level = 1;
        let isTrackingHits = false;
        let lives = 3;
        let hiScore = 0;
        let isPaused = false;

        let previousLives = lives;
        let previousLevel = level;
        let previousHiScore = hiScore;
        let startingLives = lives;

        let currentMode = 'survival';
        let currentMap = 'rectangle';

        const trail = [];
        const maxTrailLength = 20;
        const trailFadeRate = 0.1;

        let holdTimers = { play: null, mode: null, map: null };
        let buttonActivated = { play: false, mode: false, map: false };

        const gameStates = {
            'survival-rectangle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: 3 },
            'endurance-rectangle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: Infinity },
            'survival-circle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: 3 },
            'endurance-circle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false, startingLives: Infinity }
        };

        let greenSection = null;
        let redSection = null;
        let nextGreenSection = null;
        let nextRedSection = null;
        let prevGreenSection = null;
        let prevRedSection = null;

        let bulletHoles = [];
        let prevBulletHole = null; // For previous view

        let isPreviousView = false;
        let prevWallHits = 0;
        let prevLevel = 1;
        let prevLives = 3;
        let prevHiScore = 0;

        let leftPreviews = [];
        let rightPreviews = [];

        let oldGreenSection = null;
        let oldRedSection = null;

        let sweepDirection = null;
        let sweepStartTime = null;
        const sweepDuration = 500;

        function updateThrowMultiplier() {
            throwMultiplier = baseThrowMultiplier * Math.pow(throwGrowth, level - 1);
        }

        function assignSections() {
            if (currentMode === 'survival' && currentMap === 'rectangle') {
                const sections = [0, 1, 2];
                const greenIndex = Math.floor(Math.random() * sections.length);
                greenSection = sections.splice(greenIndex, 1)[0];
                const redIndex = Math.floor(Math.random() * sections.length);
                redSection = sections.splice(redIndex, 1)[0];
            } else {
                greenSection = null;
                redSection = null;
            }
        }

        function assignNextSections() {
            if (currentMode === 'survival' && currentMap === 'rectangle') {
                const sections = [0, 1, 2];
                const greenIndex = Math.floor(Math.random() * sections.length);
                nextGreenSection = sections.splice(greenIndex, 1)[0];
                const redIndex = Math.floor(Math.random() * sections.length);
                nextRedSection = sections.splice(redIndex, 1)[0];
            } else {
                nextGreenSection = null;
                nextRedSection = null;
            }
        }

        function setCanvasSize() {
            const wallHitsTop = parseInt(window.getComputedStyle(levelContainer).top) || 40;
            const wallHitsHeight = levelContainer.offsetHeight || 60;
            const wallHitsBottom = wallHitsTop + wallHitsHeight;
            const buttonHeight = modeButton.offsetHeight || 36;
            const canvasShrink = 10;
            const snugGap = 5;

            const availableHeight = window.innerHeight - wallHitsBottom - canvasShrink - buttonHeight - snugGap;
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.style.width = `${window.innerWidth * 0.9}px`;
            canvas.style.height = `${availableHeight - 2 * borderWidth}px`;
            canvas.width = window.innerWidth * 0.9 * pixelRatio;
            canvas.height = (availableHeight - 2 * borderWidth) * pixelRatio;
            ctx.scale(pixelRatio, pixelRatio);

            const canvasLeft = (window.innerWidth - (window.innerWidth * 0.9)) / 2;
            const canvasTop = wallHitsBottom + snugGap;
            canvas.style.top = `${canvasTop}px`;
            canvas.style.left = `${canvasLeft}px`;

            const canvasBottom = canvasTop + (availableHeight - 2 * borderWidth);
            countdownDisplay.style.top = `${canvasTop + 10}px`;

            const buttonTop = canvasBottom + snugGap;
            modeButton.style.top = `${buttonTop}px`;
            modeButton.style.left = `${canvasLeft}px`;

            mapButton.style.top = `${buttonTop}px`;
            mapButton.style.right = `${canvasLeft}px`;

            playButton.style.top = `${buttonTop}px`;

            livesCount.style.left = `${canvasLeft}px`;
            livesChange.style.left = `${canvasLeft + 60 + 10}px`; // Right of livesCount
            hiScoreCount.style.right = `${canvasLeft}px`;
            levelChange.style.left = `${canvasLeft + (window.innerWidth * 0.9 - 120) / 2 + 120 + 10}px`; // Right of levelContainer

            constrainCircle();
        }

        function createPreviewRect(color, top, height, left, width) {
            const rect = document.createElement('div');
            rect.classList.add('preview-rect');
            rect.style.backgroundColor = color;
            rect.style.top = `${top}px`;
            rect.style.height = `${height}px`;
            rect.style.left = `${left}px`;
            rect.style.width = `${width}px`;
            rect.style.position = 'absolute';
            return rect;
        }

        function updatePreviews() {
            // Clear existing previews
            leftPreviews.forEach(r => r.remove());
            rightPreviews.forEach(r => r.remove());
            leftPreviews = [];
            rightPreviews = [];

            if (currentMap !== 'rectangle' || currentMode !== 'survival') return;

            const canvasRect = canvas.getBoundingClientRect();
            const sectionHeight = canvasRect.height / 3;

            const canvasLeft = (window.innerWidth - window.innerWidth * 0.9) / 2;

            const leftPreviewWidth = canvasLeft + 30;
            const rightPreviewLeft = window.innerWidth - canvasLeft - 30;
            const rightPreviewWidth = canvasLeft + 30;

            // Previous previews (left)
            if (prevGreenSection !== null || prevRedSection !== null) {
                const sections = [0, 1, 2];
                const blackSection = sections.find(s => s !== prevGreenSection && s !== prevRedSection);
                const prevColors = [];
                prevColors[prevGreenSection] = 'rgb(11, 74, 28)';
                prevColors[prevRedSection] = 'rgb(130, 33, 33)';
                prevColors[blackSection] = '#000000';

                for (let i = 0; i < 3; i++) {
                    const rect = createPreviewRect(prevColors[i], canvasRect.top + i * sectionHeight, sectionHeight, 0, leftPreviewWidth);
                    if (isPaused && !isPreviousView) {
                        rect.classList.add('glow');
                        rect.classList.add('clickable');
                        rect.addEventListener('touchstart', enterPreviousView);
                    }
                    document.body.appendChild(rect);
                    leftPreviews.push(rect);
                }
            }

            // Next previews (right)
            if (nextGreenSection !== null || nextRedSection !== null) {
                const sections = [0, 1, 2];
                const blackSection = sections.find(s => s !== nextGreenSection && s !== nextRedSection);
                const nextColors = [];
                nextColors[nextGreenSection] = 'rgb(11, 74, 28)';
                nextColors[nextRedSection] = 'rgb(130, 33, 33)';
                nextColors[blackSection] = '#000000';

                for (let i = 0; i < 3; i++) {
                    const rect = createPreviewRect(nextColors[i], canvasRect.top + i * sectionHeight, sectionHeight, rightPreviewLeft, rightPreviewWidth);
                    if (isPreviousView) {
                        rect.classList.add('glow');
                    }
                    document.body.appendChild(rect);
                    rightPreviews.push(rect);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            setCanvasSize();
            assignSections();
            assignNextSections();
            requestAnimationFrame(() => setCanvasSize());
        });
        window.addEventListener('resize', setCanvasSize);

        function updateDisplay() {
            if (lives !== previousLives) {
                const livesDiff = lives - previousLives;
                if (lives > previousLives) {
                    livesCount.classList.remove('flash-green', 'flash-red');
                    void livesCount.offsetHeight;
                    livesCount.classList.add('flash-green');
                    livesChange.textContent = `+${livesDiff}`;
                    livesChange.classList.remove('plus', 'minus');
                    void livesChange.offsetHeight; // Reset animation
                    livesChange.classList.add('plus');
                } else if (lives < previousLives) {
                    livesCount.classList.remove('flash-green', 'flash-red');
                    void livesCount.offsetHeight;
                    livesCount.classList.add('flash-red');
                    livesChange.textContent = `${livesDiff}`;
                    livesChange.classList.remove('plus', 'minus');
                    void livesChange.offsetHeight; // Reset animation
                    livesChange.classList.add('minus');
                }
                previousLives = lives;
            }

            if (level !== previousLevel) {
                const levelDiff = level - previousLevel;
                if (level < previousLevel) {
                    levelNumber.classList.remove('flash-red', 'flash-white');
                    void levelNumber.offsetHeight;
                    levelNumber.classList.add('flash-red');
                    levelContainer.classList.remove('flash-green', 'flash-red');
                    void levelContainer.offsetHeight;
                    levelContainer.classList.add('flash-red');
                    levelChange.textContent = `${levelDiff}`;
                    levelChange.classList.remove('plus', 'minus');
                    void levelChange.offsetHeight; // Reset animation
                    levelChange.classList.add('minus');
                } else if (level > previousLevel) {
                    levelNumber.classList.remove('flash-red', 'flash-white');
                    void levelNumber.offsetHeight;
                    levelNumber.classList.add('flash-white');
                    levelContainer.classList.remove('flash-green', 'flash-red');
                    void levelContainer.offsetHeight;
                    levelContainer.classList.add('flash-green');
                    levelChange.textContent = `+${levelDiff}`;
                    levelChange.classList.remove('plus', 'minus');
                    void levelChange.offsetHeight; // Reset animation
                    levelChange.classList.add('plus');
                }
                previousLevel = level;
            }

            if (hiScore !== previousHiScore) {
                if (hiScore > previousHiScore) {
                    hiScoreCount.classList.remove('flash-green');
                    void hiScoreCount.offsetHeight;
                    hiScoreCount.classList.add('flash-green');
                }
                previousHiScore = hiScore;
            }

            levelNumber.textContent = `${level}`;
            livesCount.textContent = lives === Infinity ? '∞' : lives;
            hiScoreCount.textContent = hiScore;
            titleDisplay.textContent = currentMode === 'survival' ? (isPreviousView ? 'PREVIOUSLY...' : 'SURVIVAL MODE') : 'ENDURANCE MODE';
            setCanvasSize();

            playButton.textContent = isPaused ? 'RESUME' : 'PAUSE';
            countdownDisplay.style.opacity = countdownOpacity;
            countdownDisplay.textContent = countdown;

            wallHitsDisplay.textContent = `${wallHits}`;
            updatePreviews();
        }

        function constrainCircle() {
            if (currentMap === 'rectangle') {
                circle.x = Math.max(circle.radius, Math.min(canvas.width / (window.devicePixelRatio || 1) - circle.radius, circle.x));
                circle.y = Math.max(circle.radius, Math.min(canvas.height / (window.devicePixelRatio || 1) - circle.radius, circle.y));
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                if (distFromCenter + circle.radius > maxRadius) {
                    const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                    circle.x = centerX + Math.cos(angle) * (maxRadius - circle.radius);
                    circle.y = centerY + Math.sin(angle) * (maxRadius - circle.radius);
                }
            }
        }

        function saveState() {
            const key = `${currentMode}-${currentMap}`;
            gameStates[key] = {
                level,
                lives,
                hiScore,
                circle: {
                    x: circle.x,
                    y: circle.y,
                    radius: circle.radius,
                    dx: circle.dx,
                    dy: circle.dy,
                    isDragging: circle.isDragging,
                    dragTouchId: circle.dragTouchId,
                    lastX: circle.lastX,
                    lastY: circle.lastY,
                    lastTime: circle.lastTime,
                    wasDraggingWhenPaused: circle.wasDraggingWhenPaused,
                    hasBeenTouched: circle.hasBeenTouched
                },
                trail: [...trail],
                wallHits,
                isTrackingHits,
                isPaused,
                isCountingDown,
                countdown,
                countdownOpacity,
                wasDraggingWhenPaused: circle.wasDraggingWhenPaused,
                startingLives,
                greenSection,
                redSection,
                nextGreenSection,
                nextRedSection,
                prevGreenSection,
                prevRedSection
            };
            if (isCountingDown) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function loadState(mode, map) {
            const key = `${mode}-${map}`;
            const state = gameStates[key];
            level = state.level;
            lives = state.lives;
            hiScore = state.hiScore;
            wallHits = state.wallHits;
            isTrackingHits = state.isTrackingHits;
            isPaused = state.isPaused;
            isCountingDown = state.isCountingDown;
            countdown = state.countdown;
            countdownOpacity = state.countdownOpacity;
            circle.wasDraggingWhenPaused = state.wasDraggingWhenPaused;
            startingLives = state.startingLives !== undefined ? state.startingLives : (mode === 'survival' ? 3 : Infinity);
            greenSection = state.greenSection !== undefined ? state.greenSection : null;
            redSection = state.redSection !== undefined ? state.redSection : null;
            nextGreenSection = state.nextGreenSection !== undefined ? state.nextGreenSection : null;
            nextRedSection = state.nextRedSection !== undefined ? state.nextRedSection : null;
            prevGreenSection = state.prevGreenSection !== undefined ? state.prevGreenSection : null;
            prevRedSection = state.prevRedSection !== undefined ? state.prevRedSection : null;

            if (!greenSection && !redSection && mode === 'survival' && map === 'rectangle') {
                assignSections();
            }
            if (!nextGreenSection && !nextRedSection && mode === 'survival' && map === 'rectangle') {
                assignNextSections();
            }

            if (state.circle.x !== undefined) {
                circle.x = state.circle.x;
                circle.y = state.circle.y;
                circle.radius = state.circle.radius || initialRadius;
                circle.dx = state.circle.dx;
                circle.dy = state.circle.dy;
                circle.isDragging = false; // Force reset to avoid drag state leak
                circle.dragTouchId = null;
                circle.lastX = state.lastX;
                circle.lastY = state.lastY;
                circle.lastTime = state.lastTime || Date.now();
                circle.hasBeenTouched = state.circle.hasBeenTouched || false;
            } else {
                circle.x = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                circle.y = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                circle.radius = initialRadius;
                circle.dx = 0;
                circle.dy = 0;
                circle.isDragging = false;
                circle.dragTouchId = null;
                circle.lastX = circle.x;
                circle.lastY = circle.y;
                circle.lastTime = Date.now();
                circle.hasBeenTouched = false;
            }

            constrainCircle();
            trail.length = 0;
            if (state.trail && state.trail.length > 0) {
                trail.push(...state.trail);
            }

            currentMode = mode;
            currentMap = map;
            buttonActivated = { play: false, mode: false, map: false };
            holdTimers = { play: null, mode: null, map: null };
            [playButton, modeButton, mapButton].forEach(btn => {
                btn.classList.remove('glow-green', 'glow-red', 'glow-white', 'recede');
            });

            updateThrowMultiplier();
            updateDisplay();
            drawScene();
        }

        function drawSections(green, red, drawLives, drawStartingLives) {
            const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
            const sectionHeight = canvasHeight / 3;
            const pixelRatio = window.devicePixelRatio || 1;

            if (green !== null) {
                ctx.fillStyle = 'rgb(11, 74, 28)';
                ctx.fillRect(0, green * sectionHeight, canvasWidth, sectionHeight);
            }
            if (red !== null) {
                ctx.fillStyle = 'rgb(130, 33, 33)';
                ctx.fillRect(0, red * sectionHeight, canvasWidth, sectionHeight);
            }

            ctx.font = 'bold 40px Impact, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;

            const greenLives = drawStartingLives <= 3 ? drawStartingLives + 1 : (drawLives > 2 ? drawLives + 1 : 4);
            const redLives = drawStartingLives <= 3 ? Math.max(drawStartingLives - 1, 1) : (drawLives > 2 ? Math.max(drawLives - 1, 1) : 2);
            const blackSection = [0, 1, 2].find(s => s !== green && s !== red);
            const blackLives = drawStartingLives <= 3 ? drawStartingLives : (drawLives > 2 ? drawLives : 3);

            if (green !== null) {
                ctx.fillStyle = 'rgb(11, 74, 28)';
                ctx.fillText(`+${greenLives - drawLives}`, 40, green * sectionHeight + sectionHeight / 2);
                ctx.fillText(`+${greenLives - drawLives}`, canvasWidth - 40, green * sectionHeight + sectionHeight / 2);
            }
            if (red !== null) {
                ctx.fillStyle = 'rgb(130, 33, 33)';
                ctx.fillText(`${redLives - drawLives >= 0 ? '+' : ''}${redLives - drawLives}`, 40, red * sectionHeight + sectionHeight / 2);
                ctx.fillText(`${redLives - drawLives >= 0 ? '+' : ''}${redLives - drawLives}`, canvasWidth - 40, red * sectionHeight + sectionHeight / 2);
            }
            if (blackSection !== null) {
                ctx.fillStyle = '#000';
                ctx.fillText(`${blackLives - drawLives >= 0 ? '+' : ''}${blackLives - drawLives}`, 40, blackSection * sectionHeight + sectionHeight / 2);
                ctx.fillText(`${blackLives - drawLives >= 0 ? '+' : ''}${blackLives - drawLives}`, canvasWidth - 40, blackSection * sectionHeight + sectionHeight / 2);
            }

            ctx.shadowBlur = 0;
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
            const pixelRatio = window.devicePixelRatio || 1;

            let currentGreen = isPreviousView ? prevGreenSection : greenSection;
            let currentRed = isPreviousView ? prevRedSection : redSection;
            let currentLives = isPreviousView ? prevLives : lives;
            let currentStartingLives = isPreviousView ? prevStartingLives : startingLives;

            let progress = 0;
            if (sweepStartTime) {
                const elapsed = Date.now() - sweepStartTime;
                progress = Math.min(elapsed / sweepDuration, 1) * canvasWidth;
                if (progress >= canvasWidth) {
                    sweepStartTime = null;
                }
            }

            if (progress > 0) {
                if (sweepDirection === 'rightToLeft') {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(0, 0, progress, canvasHeight);
                    ctx.clip();
                    ctx.translate(-progress, 0);
                    drawSections(oldGreenSection, oldRedSection, oldDisplayLives, oldDisplayStartingLives);
                    ctx.restore();

                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(progress, 0, canvasWidth - progress, canvasHeight);
                    ctx.clip();
                    drawSections(currentGreen, currentRed, currentLives, currentStartingLives);
                    ctx.restore();
                } else if (sweepDirection === 'leftToRight') {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(canvasWidth - progress, 0, progress, canvasHeight);
                    ctx.clip();
                    ctx.translate(progress, 0);
                    drawSections(oldGreenSection, oldRedSection, oldDisplayLives, oldDisplayStartingLives);
                    ctx.restore();

                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(0, 0, canvasWidth - progress, canvasHeight);
                    ctx.clip();
                    drawSections(currentGreen, currentRed, currentLives, currentStartingLives);
                    ctx.restore();
                }
            } else {
                drawSections(currentGreen, currentRed, currentLives, currentStartingLives);
            }

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = borderWidth * 2;
            if (currentMap === 'rectangle') {
                ctx.strokeRect(0, 0, canvasWidth, canvasHeight);
            } else {
                ctx.beginPath();
                ctx.arc(canvasWidth / 2, canvasHeight / 2, Math.min(canvasWidth, canvasHeight) / 2 - borderWidth, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw bullet holes
            const holes = isPreviousView ? (prevBulletHole ? [prevBulletHole] : []) : bulletHoles;
            holes.forEach(h => {
                ctx.save();
                ctx.globalAlpha = h.opacity;

                // Draw hole
                ctx.beginPath();
                ctx.arc(h.x, h.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = h.color;
                ctx.fill();

                // White glow
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            });

            const greenColor = 'rgb(11, 74, 28)';
            let counterColor = '#e0e0e0';
            const currentWallHits = isPreviousView ? prevWallHits : wallHits;
            const currentLevel = isPreviousView ? prevLevel : level;
            if (currentWallHits === currentLevel) counterColor = greenColor;
            else if (currentWallHits > currentLevel) counterColor = 'rgb(130, 33, 33)';

            const circleColor = getCircleColor(counterColor);
            const borderColor = getBorderColor(counterColor);
            const crosshairColor = getCrosshairColor(counterColor);
            const trailBaseColor = lightenColor(counterColor);

            if (trail.length > 1) {
                ctx.beginPath();
                ctx.lineWidth = circle.radius * 2;
                ctx.lineCap = 'round';
                for (let i = 0; i < trail.length - 1; i++) {
                    const start = trail[i];
                    const end = trail[i + 1);
                    const opacity = start.opacity * (1 - (i / trail.length));
                    ctx.strokeStyle = `${trailBaseColor} ${opacity})`;
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }

            ctx.beginPath();
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            ctx.fillStyle = circleColor;
            ctx.fill();
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2 * pixelRatio;
            ctx.stroke();
            ctx.closePath();
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.strokeStyle = crosshairColor;
            ctx.lineWidth = 1 * pixelRatio;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
            const crossSize = 15;
            ctx.moveTo(circle.x - crossSize, circle.y);
            ctx.lineTo(circle.x + crossSize, circle.y);
            ctx.moveTo(circle.x, circle.y - crossSize);
            ctx.lineTo(circle.x, circle.y + crossSize);
            ctx.stroke();
            ctx.shadowBlur = 0;

            const shouldShowHoldingText = (!isPaused && circle.isDragging) || (isPaused && circle.wasDraggingWhenPaused);
            if (shouldShowHoldingText) {
                const text = "HOLDING";
                const fontSize = 24;
                const textRadius = circle.radius + 60;
                const totalLetters = text.length * 4;
                const anglePerLetter = (2 * Math.PI) / totalLetters;

                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 5 * pixelRatio;

                const startAngles = [-Math.PI / 2, 0, Math.PI / 2, Math.PI];
                for (let instance = 0; instance < 4; instance++) {
                    const startAngle = startAngles[instance];
                    for (let i = 0; i < text.length; i++) {
                        const angle = startAngle + (i * anglePerLetter);
                        const x = circle.x + textRadius * Math.cos(angle);
                        const y = circle.y + textRadius * Math.sin(angle);
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle + Math.PI / 2);
                        ctx.fillText(text[i], 0, 0);
                        ctx.restore();
                    }
                }
                ctx.shadowBlur = 0;
            }

            const offset = circle.radius + 30;

            ctx.font = 'bold 40px Impact, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = counterColor;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio;
            if (counterColor === 'rgb(11, 74, 28)') {
                ctx.shadowColor = 'rgb(50, 200, 100)';
                ctx.shadowBlur = 2 * pixelRatio;
                ctx.fillText(currentWallHits, circle.x, circle.y - offset);
                ctx.fillText(currentWallHits, circle.x, circle.y + offset);
                ctx.fillText(currentWallHits, circle.x - offset, circle.y);
                ctx.fillText(currentWallHits, circle.x + offset, circle.y);
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10 * pixelRatio;
            } else if (counterColor === 'rgb(130, 33, 33)') {
                ctx.shadowColor = 'rgb(255, 80, 80)';
                ctx.shadowBlur = 2 * pixelRatio;
                ctx.fillText(currentWallHits, circle.x, circle.y - offset);
                ctx.fillText(currentWallHits, circle.x, circle.y + offset);
                ctx.fillText(currentWallHits, circle.x - offset, circle.y);
                ctx.fillText(currentWallHits, circle.x + offset, circle.y);
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10 * pixelRatio;
            }
            ctx.fillText(currentWallHits, circle.x, circle.y - offset);
            ctx.fillText(currentWallHits, circle.x, circle.y + offset);
            ctx.fillText(currentWallHits, circle.x - offset, circle.y);
            ctx.fillText(currentWallHits, circle.x + offset, circle.y);

            ctx.fillStyle = greenColor;
            ctx.shadowColor = 'rgb(50, 200, 100)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(currentLevel, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
            ctx.fillText(currentLevel, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.fillText(currentLevel, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);

            ctx.shadowBlur = 0;
        }

        function updatePhysics() {
            if (isPaused || isPreviousView || sweepStartTime) {
                if (circle.isDragging) {
                    circle.dx = 0;
                    circle.dy = 0;
                }
                return;
            }

            const currentTime = Date.now();

            if (!circle.isDragging) {
                circle.dy += gravity;
                circle.x += circle.dx;
                circle.y += circle.dy;
                circle.dx *= friction;
                circle.dy *= friction;

                const velocity = Math.sqrt(circle.dx * circle.dx + circle.dy * circle.dy);
                const trailLength = Math.min(maxTrailLength, Math.floor(velocity / 10));
                trail.unshift({ x: circle.x, y: circle.y, opacity: 1 });
                while (trail.length > trailLength) trail.pop();
                for (let i = 0; i < trail.length; i++) {
                    trail[i].opacity -= trailFadeRate;
                    if (trail[i].opacity <= 0) trail.splice(i, 1);
                }

                let walls;
                if (currentMap === 'rectangle') {
                    walls = [
                        { name: 'right', edge: canvas.width / (window.devicePixelRatio || 1), pos: circle.x + circle.radius, velocity: circle.dx, isContact: circle.x + circle.radius >= canvas.width / (window.devicePixelRatio || 1) },
                        { name: 'left', edge: 0, pos: circle.x - circle.radius, velocity: circle.dx, isContact: circle.x - circle.radius <= 0 },
                        { name: 'bottom', edge: canvas.height / (window.devicePixelRatio || 1), pos: circle.y + circle.radius, velocity: circle.dy, isContact: circle.y + circle.radius >= canvas.height / (window.devicePixelRatio || 1) },
                        { name: 'top', edge: 0, pos: circle.y - circle.radius, velocity: circle.dy, isContact: circle.y - circle.radius <= 0 }
                    ];
                } else {
                    const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                    const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                    const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                    const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                    const isContact = distFromCenter + circle.radius >= radius;
                    walls = [{ name: 'boundary', edge: radius, pos: distFromCenter + circle.radius, velocity: 0, isContact }];
                }

                walls.forEach(wall => {
                    const contact = circle.wallContact[wall.name];
                    if (wall.isContact) {
                        if (!contact.inContact) {
                            contact.inContact = true;
                            contact.time = currentTime;
                            if (isTrackingHits) {
                                wallHits++;
                                wallHitsDisplay.textContent = `${wallHits}`;
                                const greenColor = 'rgb(11, 74, 28)';
                                let counterColor = '#e0e0e0';
                                if (wallHits === level) counterColor = greenColor;
                                else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';
                                wallHitsDisplay.style.color = counterColor;
                                if (counterColor === '#e0e0e0') {
                                    wallHitsDisplay.classList.remove('bright-glow');
                                    wallHitsDisplay.style.textShadow = '0 0 5px #fff';
                                } else {
                                    wallHitsDisplay.classList.add('bright-glow');
                                    const outlineColor = counterColor === greenColor ? 'rgb(50, 200, 100)' : 'rgb(255, 80, 80)';
                                    wallHitsDisplay.style.setProperty('--outline-color', outlineColor);
                                    wallHitsDisplay.style.textShadow = `0 0 10px #fff, 0 0 2px ${outlineColor}`;
                                }
                            }
                        }
                    } else {
                        if (contact.inContact) {
                            contact.inContact = false;
                        }
                    }
                });

                if (currentMap === 'rectangle') {
                    if (circle.x + circle.radius > canvas.width / (window.devicePixelRatio || 1)) {
                        circle.x = (canvas.width / (window.devicePixelRatio || 1)) - circle.radius;
                        circle.dx = -circle.dx * bounciness;
                    } else if (circle.x - circle.radius < 0) {
                        circle.x = circle.radius;
                        circle.dx = -circle.dx * bounciness;
                    }
                    if (circle.y + circle.radius > canvas.height / (window.devicePixelRatio || 1)) {
                        circle.y = (canvas.height / (window.devicePixelRatio || 1)) - circle.radius;
                        circle.dy = -circle.dy * bounciness;
                    } else if (circle.y - circle.radius < 0) {
                        circle.y = circle.radius;
                        circle.dy = -circle.dy * bounciness;
                    }
                } else {
                    const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                    const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                    const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                    const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                    if (distFromCenter + circle.radius >= radius) {
                        const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                        circle.x = centerX + Math.cos(angle) * (radius - circle.radius);
                        circle.y = centerY + Math.sin(angle) * (radius - circle.radius);
                        const speed = Math.sqrt(circle.dx ** 2 + circle.dy ** 2);
                        circle.dx = -Math.cos(angle) * speed * bounciness;
                        circle.dy = -Math.sin(angle) * speed * bounciness;
                    }
                }
            }

            // Update bullet holes opacity
            const now = Date.now();
            bulletHoles.forEach(h => {
                h.opacity = Math.max(0, 1 - (now - h.startTime) / 2000);
            });
            bulletHoles = bulletHoles.filter(h => h.opacity > 0);
        }

        function startCountdown(isResuming = false) {
            if (!isResuming) {
                isCountingDown = true;
                countdown = 3;
                wallHits = 0;
                wallHitsDisplay.textContent = `${wallHits}`;
                wallHitsDisplay.style.color = '#e0e0e0';
                wallHitsDisplay.classList.remove('bright-glow');
                wallHitsDisplay.style.textShadow = '0 0 5px #fff';
                isTrackingHits = true;
                countdownOpacity = 1;
            } else {
                isCountingDown = true;
            }
            countdownDisplay.style.opacity = countdownOpacity;
            countdownDisplay.textContent = countdown;

            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDisplay.textContent = countdown;
                } else {
                    countdownOpacity = 0;
                    countdownDisplay.style.opacity = countdownOpacity;
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    isCountingDown = false;
                    updateDisplay();
                }
            }, 1000);
        }

        function getMousePos(e, touchId = null) {
            const rect = canvas.getBoundingClientRect();
            if (touchId !== null && e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        return {
                            x: e.touches[i].clientX - rect.left,
                            y: e.touches[i].clientY - rect.top
                        };
                    }
                }
            }
            return {
                x: (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left,
                y: (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top
            };
        }

        function getScreenPos(e, touchId = null) {
            if (touchId !== null && (e.touches || e.changedTouches)) {
                const touches = e.changedTouches || e.touches;
                for (let i = 0; i < touches.length; i++) {
                    if (touches[i].identifier === touchId) {
                        return {
                            x: touches[i].clientX,
                            y: touches[i].clientY
                        };
                    }
                }
            }
            return {
                x: e.clientX || (e.touches && e.touches[0].clientX) || (e.changedTouches && e.changedTouches[0].clientX),
                y: e.clientY || (e.touches && e.touches[0].clientY) || (e.changedTouches && e.changedTouches[0].clientY)
            };
        }

        function addBulletHole(x, y, bgColor, isBlackIfCondition) {
            let color = bgColor;
            if (isBlackIfCondition && bgColor === '#000000') {
                color = '#000000';
            } else if (bgColor === '#000000') {
                color = '#333333'; // Default for visibility
            }
            bulletHoles.push({ x, y, startTime: Date.now(), color, opacity: 1 });
        }

        function handleCanvasTap(e) {
            if (isPaused || isPreviousView) return;
            const pos = getMousePos(e);
            e.preventDefault();

            const originalX = circle.x;
            const originalY = circle.y;

            if (circle.isDragging) return;

            if (!circle.hasBeenTouched) {
                circle.hasBeenTouched = true;
                startCountdown();
                circle.x = pos.x;
                circle.y = pos.y;
                constrainCircle();
                return;
            }

            let bgColor = '#000000';
            let isBlackIfCondition = (wallHits >= level || !isCountingDown);
            if (currentMode === 'survival' && currentMap === 'rectangle') {
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                const sectionHeight = canvasHeight / 3;
                const section = Math.floor(originalY / sectionHeight);
                if (section === greenSection) bgColor = 'rgb(11, 74, 28)';
                else if (section === redSection) bgColor = 'rgb(130, 33, 33)';
                else bgColor = '#000000';
            }

            addBulletHole(originalX, originalY, bgColor, isBlackIfCondition);

            if (isCountingDown) {
                if (wallHits === level) {
                    handleWin(originalX, originalY, bgColor, isBlackIfCondition);
                }
                circle.x = pos.x;
                circle.y = pos.y;
                constrainCircle();
                return;
            }

            // New tap-to-move and win/lose logic using original position
            if (wallHits === level) {
                handleWin(originalX, originalY, bgColor, isBlackIfCondition);
            } else if (wallHits > level && currentMode === 'survival') {
                lives--;
                if (lives <= 0) {
                    level = 1;
                    updateThrowMultiplier();
                    lives = 3;
                    startingLives = 3;
                }
                wallHits = 0;
                saveState();
                updateDisplay();
                startCountdown();
            } else if (wallHits < level && currentMode === 'survival') {
                lives--;
                if (lives <= 0) {
                    level = 1;
                    updateThrowMultiplier();
                    lives = 3;
                    startingLives = 3;
                }
                wallHits = 0;
                saveState();
                updateDisplay();
                startCountdown();
            } else {
                wallHits = 0;
                startCountdown();
            }

            circle.x = pos.x;
            circle.y = pos.y;
            constrainCircle();
        }

        function handleWin(originalX, originalY, bgColor, isBlackIfCondition) {
            isTrackingHits = false;
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                countdownOpacity = 0;
                countdownDisplay.style.opacity = countdownOpacity;
                isCountingDown = false;
            }
            const completedLevel = level;
            prevBulletHole = { x: originalX, y: originalY, color: isBlackIfCondition && bgColor === '#000000' ? '#000000' : bgColor, opacity: 1 };
            prevWallHits = wallHits;
            prevLevel = level;
            prevLives = lives;
            prevHiScore = hiScore;
            level++;
            updateThrowMultiplier();
            let flashColor = null;

            if (currentMode === 'survival' && currentMap === 'rectangle') {
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                const sectionHeight = canvasHeight / 3;
                const circleSection = Math.floor(originalY / sectionHeight); // Use original position

                let baseLives;
                if (startingLives > 3 && lives < 3) baseLives = 3;
                else if (startingLives > 3 && lives > 2) baseLives = lives;
                else baseLives = startingLives;

                if (circleSection === greenSection) {
                    lives = baseLives + 1;
                    flashColor = 'flash-green';
                } else if (circleSection === redSection) {
                    lives = Math.max(baseLives - 1, 1);
                    flashColor = 'flash-red';
                } else {
                    lives = baseLives;
                }
            } else if (currentMode === 'survival') {
                lives = 3;
            }

            if (completedLevel > hiScore) hiScore = completedLevel;
            wallHits = 0;
            if (flashColor) {
                canvas.classList.remove('flash-green', 'flash-red');
                void canvas.offsetHeight;
                canvas.classList.add(flashColor);
            }
            startingLives = lives;
            prevGreenSection = greenSection;
            prevRedSection = redSection;
            greenSection = nextGreenSection;
            redSection = nextRedSection;
            assignNextSections();
            oldGreenSection = prevGreenSection;
            oldRedSection = prevRedSection;
            oldDisplayLives = prevLives;
            oldDisplayStartingLives = prevStartingLives;
            sweepDirection = 'rightToLeft';
            sweepStartTime = Date.now();
            bulletHoles = [];
            saveState();
            updateDisplay();
            startCountdown();
        }

        function enterPreviousView(e) {
            if (!isPaused || isPreviousView) return;
            isPreviousView = true;

            // Save current
            const tempGreen = greenSection;
            const tempRed = redSection;
            const tempLives = lives;
            const tempStartingLives = startingLives;

            oldGreenSection = greenSection;
            oldRedSection = redSection;
            oldDisplayLives = lives;
            oldDisplayStartingLives = startingLives;

            greenSection = prevGreenSection;
            redSection = prevRedSection;
            lives = prevLives;
            startingLives = prevStartingLives;
            nextGreenSection = tempGreen;
            nextRedSection = tempRed;

            prevGreenSection = null;
            prevRedSection = null;

            // Animations for previews
            leftPreviews.forEach(r => {
                r.style.animation = 'sweepToRight 0.5s ease forwards';
                setTimeout(() => r.remove(), 500);
            });
            leftPreviews = [];
            rightPreviews.forEach(r => {
                r.style.animation = 'sweepToRight 0.5s ease forwards';
                setTimeout(() => r.remove(), 500);
            });

            // Create new right previews
            updatePreviews();

            rightPreviews.forEach(r => {
                r.style.transform = 'translateX(-100%)';
                r.style.animation = 'sweepFromLeft 0.5s ease forwards';
            });

            // Buttons
            [playButton, modeButton, mapButton].forEach(btn => {
                btn.style.animation = 'sweepUpward 0.5s ease forwards';
                setTimeout(() => btn.style.display = 'none', 500);
            });

            // Title
            titleDisplay.style.animation = 'sweepRightward 0.5s ease forwards';
            setTimeout(() => {
                titleDisplay.textContent = 'PREVIOUSLY...';
                titleDisplay.style.animation = 'sweepLeftwardIn 0.5s ease forwards';
            }, 500);

            // Numbers
            levelContainer.style.animation = 'sweepRightward 0.5s ease forwards';
            livesCount.style.animation = 'sweepRightward 0.5s ease forwards';
            hiScoreCount.style.animation = 'sweepRightward 0.5s ease forwards';
            setTimeout(() => {
                wallHitsDisplay.textContent = prevWallHits;
                levelNumber.textContent = prevLevel;
                wallHitsDisplay.style.color = 'rgb(11, 74, 28)';
                levelNumber.style.color = 'rgb(11, 74, 28)';
                livesCount.textContent = prevLives;
                hiScoreCount.textContent = prevHiScore;
                levelContainer.style.animation = 'sweepLeftwardIn 0.5s ease forwards';
                livesCount.style.animation = 'sweepLeftwardIn 0.5s ease forwards';
                hiScoreCount.style.animation = 'sweepLeftwardIn 0.5s ease forwards';
            }, 500);

            sweepDirection = 'leftToRight';
            sweepStartTime = Date.now();

            document.addEventListener('touchstart', exitPreviousView, { once: true });

            drawScene();
        }

        function exitPreviousView(e) {
            isPreviousView = false;

            // Restore
            const tempGreen = greenSection;
            const tempRed = redSection;
            const tempLives = lives;
            const tempStartingLives = startingLives;

            oldGreenSection = greenSection;
            oldRedSection = redSection;
            oldDisplayLives = lives;
            oldDisplayStartingLives = startingLives;

            greenSection = nextGreenSection;
            redSection = nextRedSection;
            lives = tempLives;
            startingLives = tempStartingLives;

            nextGreenSection = null;
            nextRedSection = null;
            prevGreenSection = tempGreen;
            prevRedSection = tempRed;

            // Animations for previews
            rightPreviews.forEach(r => {
                r.style.animation = 'sweepToLeft 0.5s ease forwards';
                setTimeout(() => r.remove(), 500);
            });

            // Create new left previews
            updatePreviews();

            leftPreviews.forEach(r => {
                r.style.transform = 'translateX(-100%)';
                r.style.animation = 'sweepFromLeft 0.5s ease forwards';
            });

            // Buttons
            [playButton, modeButton, mapButton].forEach(btn => {
                btn.style.display = 'block';
                btn.style.animation = 'sweepUpward 0.5s ease reverse';
            });

            // Title
            titleDisplay.style.animation = 'sweepRightward 0.5s ease reverse';
            setTimeout(() => {
                titleDisplay.textContent = 'SURVIVAL MODE';
                titleDisplay.style.animation = 'sweepLeftwardIn 0.5s ease reverse';
            }, 500);

            // Numbers
            levelContainer.style.animation = 'sweepRightward 0.5s ease reverse';
            livesCount.style.animation = 'sweepRightward 0.5s ease reverse';
            hiScoreCount.style.animation = 'sweepRightward 0.5s ease reverse';
            setTimeout(() => {
                wallHitsDisplay.textContent = wallHits;
                levelNumber.textContent = level;
                wallHitsDisplay.style.color = '#e0e0e0';
                levelNumber.style.color = 'rgb(11, 74, 28)';
                livesCount.textContent = lives;
                hiScoreCount.textContent = hiScore;
                levelContainer.style.animation = 'sweepLeftwardIn 0.5s ease reverse';
                livesCount.style.animation = 'sweepLeftwardIn 0.5s ease reverse';
                hiScoreCount.style.animation = 'sweepLeftwardIn 0.5s ease reverse';
            }, 500);

            sweepDirection = 'rightToLeft';
            sweepStartTime = Date.now();

            drawScene();
        }

        function animateLevelChange() {
            sweepDirection = 'rightToLeft';
            sweepStartTime = Date.now();

            // Animate old previews
            leftPreviews.forEach(r => {
                r.style.animation = 'sweepToLeft 0.5s ease forwards';
                setTimeout(() => r.remove(), 500);
            });
            rightPreviews.forEach(r => {
                r.style.animation = 'sweepToLeft 0.5s ease forwards';
                setTimeout(() => r.remove(), 500);
            });

            // Create new previews
            updatePreviews();

            leftPreviews.forEach(r => {
                r.style.transform = 'translateX(100%)';
                r.style.animation = 'sweepFromRight 0.5s ease forwards';
            });
            rightPreviews.forEach(r => {
                r.style.transform = 'translateX(100%)';
                r.style.animation = 'sweepFromRight 0.5s ease forwards';
            });
        }

        // ... (other functions like startDragging, drag, stopDragging, etc.)

        function animate() {
            updatePhysics();
            drawScene();
            requestAnimationFrame(animate);
        }

        circle.x = window.innerWidth * 0.45;
        circle.y = window.innerHeight * 0.5;

        updateThrowMultiplier();
        updateDisplay();
        drawScene();
        animate();
    </script>
</body>
</html>
