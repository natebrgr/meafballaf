<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throwable Bouncy Circle Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: rgb(5, 5, 25); /* Fallback static dark blue */
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.9) 100%);
            pointer-events: none;
            z-index: 1;
        }
        canvas {
            position: absolute;
            z-index: 5;
            background: transparent;
            pointer-events: auto;
        }
        #levelContainer, #countdown, #title, #sighhh {
            position: absolute;
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff;
            font-weight: bold;
            z-index: 2;
        }
        #title {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
        }
        #levelContainer {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            width: 120px;
            height: 60px;
            background: transparent;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
        }
        #wallHits, #levelNumber {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Impact', sans-serif;
            font-size: 2.5em;
        }
        #wallHits {
            text-shadow: 0 0 5px #fff; /* White glow for white text */
            border-right: 2px solid #e0e0e0;
        }
        #wallHits.bright-glow {
            text-shadow: 0 0 10px #fff, 0 0 2px var(--outline-color); /* White glow + outline */
        }
        #levelNumber {
            color: rgb(11, 74, 28); /* Always green */
            text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); /* White glow + green outline */
        }
        #levelNumber.flash-red {
            animation: flashRedLevel 0.5s ease;
        }
        #levelNumber.flash-white {
            animation: flashWhiteLevel 0.5s ease;
        }
        #countdown {
            left: 50%;
            transform: translateX(-50%);
            font-size: 4em;
            transition: opacity 0.5s ease;
            z-index: 10;
            pointer-events: none;
        }
        #sighhh {
            left: 50%;
            transform: translateX(-50%);
            font-size: 1em;
            visibility: hidden;
            text-shadow: 0 0 10px rgb(130, 33, 33);
            z-index: 10;
        }
        #sighhh.yee-haw {
            text-shadow: 0 0 10px rgb(11, 74, 28);
        }
        #fleepSpan {
            cursor: pointer;
            display: inline-block;
            pointer-events: auto;
        }
        #livesCount, #hiScoreCount {
            color: #e0e0e0;
            text-shadow: 0 0 5px #fff; /* White glow for white text */
            font-size: 2.5em;
            position: absolute;
            z-index: 2;
            font-family: 'Impact', sans-serif;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            top: 40px;
        }
        #livesCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #livesCount.flash-red {
            animation: flashRed 0.5s ease;
        }
        #hiScoreCount.flash-green {
            animation: flashGreen 0.5s ease;
        }
        #modeButton, #mapButton {
            position: absolute;
            z-index: 15;
        }
        #playButton {
            position: absolute;
            z-index: 20;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            font-size: 1em;
            display: block;
        }
        button {
            padding: 8px 16px;
            font-size: 1em;
            font-weight: bold;
            font-family: Arial, sans-serif;
            cursor: pointer;
            text-shadow: 0 0 5px #fff;
            border: none;
            border-radius: 5px;
            filter: drop-shadow(0 0 5px #fff);
            z-index: 25;
            pointer-events: auto;
        }
        button:hover {
            filter: drop-shadow(0 0 5px #fff) brightness(85%);
        }
        #playButton.glow-green {
            animation: glowGreen 1s linear forwards;
        }
        #playButton.glow-red {
            animation: glowRed 1s linear forwards;
        }
        #modeButton.glow-white, #mapButton.glow-white {
            animation: glowWhite 1s linear forwards;
        }
        #playButton.recede, #modeButton.recede, #mapButton.recede {
            animation: recedeGlow 0.2s linear forwards;
        }
        @keyframes glowGreen {
            0% { box-shadow: 0 0 5px rgb(11, 74, 28); }
            100% { box-shadow: 0 0 20px rgb(11, 74, 28); }
        }
        @keyframes glowRed {
            0% { box-shadow: 0 0 5px rgb(130, 33, 33); }
            100% { box-shadow: 0 0 20px rgb(130, 33, 33); }
        }
        @keyframes glowWhite {
            0% { box-shadow: 0 0 5px #ffffff; }
            100% { box-shadow: 0 0 20px #ffffff; }
        }
        @keyframes recedeGlow {
            0% { box-shadow: 0 0 20px; }
            100% { box-shadow: 0 0 0; }
        }
        @keyframes flashGreen {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; }
            50% { color: rgb(11, 74, 28); text-shadow: 0 0 5px #fff; }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; }
        }
        @keyframes flashRed {
            0% { color: #e0e0e0; text-shadow: 0 0 5px #fff; }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 5px #fff; }
            100% { color: #e0e0e0; text-shadow: 0 0 5px #fff; }
        }
        @keyframes flashRedLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: rgb(130, 33, 33); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        @keyframes flashWhiteLevel {
            0% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            50% { color: #e0e0e0; text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
            100% { color: rgb(11, 74, 28); text-shadow: 0 0 10px #fff, 0 0 2px rgb(50, 200, 100); }
        }
        #fleepMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #e0e0e0;
            text-shadow: 0 0 10px rgb(130, 33, 33);
            opacity: 0;
            z-index: 30;
            pointer-events: none;
        }
        #blackOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            z-index: 25;
            pointer-events: none;
            transition: background 1s ease;
        }
    </style>
</head>
<body>
    <div id="title">Survival Mode</div>
    <div id="levelContainer">
        <div id="wallHits">0</div>
        <div id="levelNumber">1</div>
    </div>
    <div id="countdown" style="opacity: 0;"></div>
    <div id="livesCount">3</div>
    <div id="hiScoreCount">0</div>
    <button id="modeButton">MODE</button>
    <button id="mapButton">MAP</button>
    <canvas id="canvas"></canvas>
    <button id="playButton">PAUSE</button>
    <div id="sighhh"></div>
    <div id="fleepMessage">Fleep is nigh...</div>
    <div id="blackOverlay"></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const levelContainer = document.getElementById('levelContainer');
        const levelNumber = document.getElementById('levelNumber');
        const countdownDisplay = document.getElementById('countdown');
        const wallHitsDisplay = document.getElementById('wallHits');
        const livesCount = document.getElementById('livesCount');
        const hiScoreCount = document.getElementById('hiScoreCount');
        const titleDisplay = document.getElementById('title');
        const modeButton = document.getElementById('modeButton');
        const mapButton = document.getElementById('mapButton');
        const playButton = document.getElementById('playButton');
        const sighhhDisplay = document.getElementById('sighhh');
        const fleepMessage = document.getElementById('fleepMessage');
        const blackOverlay = document.getElementById('blackOverlay');

        const borderWidth = 2;
        const defaultRadius = 30; // Minimum radius for resizing
        const initialRadius = 60; // Initial radius on page load
        const resizeHoldThreshold = 200;

        const circle = {
            x: 0,
            y: 0,
            radius: initialRadius, // Start at 60
            dx: 0,
            dy: 0,
            isDragging: false,
            dragTouchId: null,
            wasDraggingWhenPaused: false,
            lastX: 0,
            lastY: 0,
            lastTime: 0,
            wallContact: {
                left: { time: 0, inContact: false },
                right: { time: 0, inContact: false },
                top: { time: 0, inContact: false },
                bottom: { time: 0, inContact: false },
                boundary: { time: 0, inContact: false }
            },
            resizeTouchId: null,
            isResizing: false,
            resizeStartX: 0,
            resizeStartY: 0,
            initialRadius: initialRadius, // Start at 60
            resizeStartTime: 0,
            resizeTimer: null
        };

        const gravity = 0.5;
        const friction = 0.98;
        const bounciness = 0.9;
        const bounceTimeWindow = 100;

        let isCountingDown = false;
        let countdown = 3;
        let countdownInterval = null;
        let countdownOpacity = 0;
        let wallHits = 0;
        let level = 1;
        let isTrackingHits = false;
        let lives = 3;
        let hiScore = 0;
        let isPaused = false;
        let isFleepSequence = false;

        let previousLives = lives;
        let previousLevel = level;
        let previousHiScore = hiScore;

        let currentMode = 'survival';
        let currentMap = 'rectangle';

        const trail = [];
        const maxTrailLength = 20;
        const trailFadeRate = 0.1;

        let shownTexts = new Set();
        let currentSighhhText = '';
        let sighhhVisible = false;
        let sighhhTimer = null;

        let holdTimers = { play: null, mode: null, map: null };
        let buttonActivated = { play: false, mode: false, map: false };

        const gameStates = {
            'survival-rectangle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
            'endurance-rectangle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
            'survival-circle': { level: 1, lives: 3, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false },
            'endurance-circle': { level: 1, lives: Infinity, hiScore: 0, circle: {}, trail: [], wallHits: 0, isTrackingHits: false, isPaused: false, isCountingDown: false, countdown: 3, countdownOpacity: 0, wasDraggingWhenPaused: false }
        };

        function setCanvasSize() {
            const wallHitsTop = parseInt(window.getComputedStyle(levelContainer).top) || 40;
            const wallHitsHeight = levelContainer.offsetHeight || 60;
            const wallHitsBottom = wallHitsTop + wallHitsHeight;
            const buttonHeight = modeButton.offsetHeight || 36;
            const canvasShrink = 10;
            const snugGap = 5;

            const availableHeight = window.innerHeight - wallHitsBottom - canvasShrink - buttonHeight - snugGap;
            const pixelRatio = window.devicePixelRatio || 1;
            canvas.style.width = `${window.innerWidth * 0.9}px`;
            canvas.style.height = `${availableHeight - 2 * borderWidth}px`;
            canvas.width = window.innerWidth * 0.9 * pixelRatio;
            canvas.height = (availableHeight - 2 * borderWidth) * pixelRatio;
            ctx.scale(pixelRatio, pixelRatio);

            const canvasLeft = (window.innerWidth - (window.innerWidth * 0.9)) / 2;
            const canvasTop = wallHitsBottom + snugGap;
            canvas.style.top = `${canvasTop}px`;
            canvas.style.left = `${canvasLeft}px`;

            const canvasBottom = canvasTop + (availableHeight - 2 * borderWidth);
            const canvasHeight = availableHeight - 2 * borderWidth;
            const countdownTop = canvasTop + (canvasHeight * 1 / 6); // 1/6 from the top of the canvas
            countdownDisplay.style.top = `${countdownTop}px`;

            const buttonTop = canvasBottom + snugGap;
            modeButton.style.top = `${buttonTop}px`;
            modeButton.style.bottom = '';
            modeButton.style.left = `${canvasLeft}px`;

            mapButton.style.top = `${buttonTop}px`;
            mapButton.style.bottom = '';
            mapButton.style.right = `${window.innerWidth - (canvasLeft + (window.innerWidth * 0.9))}px`;

            playButton.style.top = `${buttonTop}px`;
            playButton.style.bottom = '';

            livesCount.style.left = `${canvasLeft}px`;
            hiScoreCount.style.right = `${window.innerWidth - (canvasLeft + (window.innerWidth * 0.9))}px`;

            sighhhDisplay.style.top = `${wallHitsBottom + 10}px`;

            constrainCircle();
        }

        document.addEventListener('DOMContentLoaded', () => {
            setCanvasSize();
            requestAnimationFrame(() => setCanvasSize());
            // Start the countdown on game load to ensure wall hits are tracked
            startCountdown();
        });
        window.addEventListener('resize', setCanvasSize);

        function updateDisplay() {
            // Check for changes in lives, level, and hiScore to trigger flashes
            if (lives !== previousLives) {
                if (lives > previousLives) {
                    livesCount.classList.remove('flash-green', 'flash-red');
                    void livesCount.offsetHeight; // Trigger reflow to restart animation
                    livesCount.classList.add('flash-green');
                } else if (lives < previousLives) {
                    livesCount.classList.remove('flash-green', 'flash-red');
                    void livesCount.offsetHeight; // Trigger reflow to restart animation
                    livesCount.classList.add('flash-red');
                }
                previousLives = lives;
            }

            if (level !== previousLevel) {
                if (level < previousLevel) {
                    levelNumber.classList.remove('flash-red', 'flash-white');
                    void levelNumber.offsetHeight; // Trigger reflow to restart animation
                    levelNumber.classList.add('flash-red');
                } else if (level > previousLevel) {
                    levelNumber.classList.remove('flash-red', 'flash-white');
                    void levelNumber.offsetHeight; // Trigger reflow to restart animation
                    levelNumber.classList.add('flash-white');
                }
                previousLevel = level;
            }

            if (hiScore !== previousHiScore) {
                if (hiScore > previousHiScore) {
                    hiScoreCount.classList.remove('flash-green');
                    void hiScoreCount.offsetHeight; // Trigger reflow to restart animation
                    hiScoreCount.classList.add('flash-green');
                }
                previousHiScore = hiScore;
            }

            levelNumber.textContent = `${level}`;
            livesCount.textContent = lives === Infinity ? 'âˆž' : lives;
            hiScoreCount.textContent = hiScore;
            titleDisplay.textContent = currentMode === 'survival' ? 'Survival Mode' : 'Endurance Mode';
            setCanvasSize();

            playButton.textContent = isPaused ? 'RESUME' : 'PAUSE';
            countdownDisplay.style.opacity = countdownOpacity;
            countdownDisplay.textContent = countdown;

            sighhhDisplay.innerHTML = currentSighhhText === 'SIGHHH me to FLEEP' 
                ? 'SIGHHH me to <span id="fleepSpan">FLEEP</span>' 
                : currentSighhhText;
            sighhhDisplay.style.visibility = sighhhVisible ? 'visible' : 'hidden';
            sighhhDisplay.classList.toggle('yee-haw', currentSighhhText === 'yee haw BII');

            const fleepSpan = document.getElementById('fleepSpan');
            if (fleepSpan && !fleepSpan.onclick) {
                fleepSpan.onclick = triggerFleepSequence;
            }

            wallHitsDisplay.textContent = `${wallHits}`;
        }

        function showText(text) {
            if (!shownTexts.has(text)) {
                shownTexts.add(text);
                currentSighhhText = text;
                sighhhVisible = true;
                updateDisplay();
                if (sighhhTimer) clearTimeout(sighhhTimer);
                sighhhTimer = setTimeout(() => {
                    sighhhVisible = false;
                    updateDisplay();
                }, 2000);
            }
        }

        function triggerFleepSequence() {
            if (isFleepSequence) return;
            isFleepSequence = true;

            const savedState = {
                circleDx: circle.dx,
                circleDy: circle.dy,
                countdownInterval: countdownInterval,
                sighhhTimer: sighhhTimer,
                sighhhTimerStart: sighhhTimer ? Date.now() : null
            };

            if (countdownInterval) clearInterval(countdownInterval);
            if (sighhhTimer) clearTimeout(sighhhTimer);
            circle.dx = 0;
            circle.dy = 0;

            blackOverlay.style.transition = 'background 1s ease';
            blackOverlay.style.background = 'rgba(0, 0, 0, 1)';
            
            setTimeout(() => {
                fleepMessage.style.transition = 'opacity 1s ease';
                fleepMessage.style.opacity = '1';
                
                setTimeout(() => {
                    setTimeout(() => {
                        fleepMessage.style.opacity = '0';
                        
                        setTimeout(() => {
                            blackOverlay.style.background = 'rgba(0, 0, 0, 0)';
                            
                            setTimeout(() => {
                                circle.dx = savedState.circleDx;
                                circle.dy = savedState.circleDy;
                                if (savedState.countdownInterval) {
                                    countdownInterval = setInterval(() => {
                                        countdown--;
                                        if (countdown > 0) {
                                            countdownDisplay.textContent = countdown;
                                        } else {
                                            countdownOpacity = 0;
                                            countdownDisplay.style.opacity = countdownOpacity;
                                            clearInterval(countdownInterval);
                                            countdownInterval = null;
                                            isCountingDown = false;
                                            updateDisplay();
                                        }
                                    }, 1000);
                                }
                                if (savedState.sighhhTimer) {
                                    const elapsed = Date.now() - savedState.sighhhTimerStart;
                                    const remaining = Math.max(2000 - elapsed, 0);
                                    sighhhTimer = setTimeout(() => {
                                        sighhhVisible = false;
                                        updateDisplay();
                                    }, remaining);
                                }
                                isFleepSequence = false;
                                blackOverlay.style.transition = '';
                                fleepMessage.style.transition = '';
                            }, 1000);
                        }, 1000);
                    }, 1000);
                }, 1000);
            }, 1000);
        }

        function constrainCircle() {
            if (currentMap === 'rectangle') {
                circle.x = Math.max(circle.radius, Math.min(canvas.width / (window.devicePixelRatio || 1) - circle.radius, circle.x));
                circle.y = Math.max(circle.radius, Math.min(canvas.height / (window.devicePixelRatio || 1) - circle.radius, circle.y));
            } else {
                const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                if (distFromCenter + circle.radius > maxRadius) {
                    const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                    circle.x = centerX + Math.cos(angle) * (maxRadius - circle.radius);
                    circle.y = centerY + Math.sin(angle) * (maxRadius - circle.radius);
                }
            }
        }

        function saveState() {
            const key = `${currentMode}-${currentMap}`;
            gameStates[key] = {
                level,
                lives,
                hiScore,
                circle: {
                    x: circle.x,
                    y: circle.y,
                    radius: circle.radius,
                    dx: circle.dx,
                    dy: circle.dy,
                    isDragging: circle.isDragging,
                    dragTouchId: circle.dragTouchId,
                    lastX: circle.lastX,
                    lastY: circle.lastY,
                    lastTime: circle.lastTime,
                    wasDraggingWhenPaused: circle.wasDraggingWhenPaused
                },
                trail: [...trail],
                wallHits,
                isTrackingHits,
                isPaused,
                isCountingDown,
                countdown,
                countdownOpacity,
                wasDraggingWhenPaused: circle.wasDraggingWhenPaused
            };
            if (isCountingDown) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function loadState(mode, map) {
            const key = `${mode}-${map}`;
            const state = gameStates[key];
            level = state.level;
            lives = state.lives;
            hiScore = state.hiScore;
            wallHits = state.wallHits;
            isTrackingHits = state.isTrackingHits;
            isPaused = state.isPaused;
            isCountingDown = state.isCountingDown;
            countdown = state.countdown;
            countdownOpacity = state.countdownOpacity;
            circle.wasDraggingWhenPaused = state.wasDraggingWhenPaused;

            if (state.circle.x !== undefined) {
                circle.x = state.circle.x;
                circle.y = state.circle.y;
                circle.radius = state.circle.radius || initialRadius; // Use initialRadius (60) if no saved radius
                circle.dx = state.circle.dx;
                circle.dy = state.dy;
                circle.isDragging = state.isDragging;
                circle.dragTouchId = state.dragTouchId;
                circle.lastX = state.lastX;
                circle.lastY = state.lastY;
                circle.lastTime = state.lastTime || Date.now();
            } else {
                circle.x = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                circle.y = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                circle.radius = initialRadius; // Start at 60
                circle.dx = 0;
                circle.dy = 0;
                circle.isDragging = false;
                circle.dragTouchId = null;
                circle.lastX = circle.x;
                circle.lastY = circle.y;
                circle.lastTime = Date.now();
            }

            constrainCircle();
            trail.length = 0;
            if (state.trail && state.trail.length > 0) {
                trail.push(...state.trail);
            }

            updateDisplay();
            requestAnimationFrame(() => drawScene(updateColors()));
        }

        function updateColors() {
            // Static colors: rgb(5, 5, 25) for dark, #e0e0e0 for inverted
            const r = 5;
            const g = 5;
            const b = 25;

            document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

            const textColor = `rgb(${r}, ${g}, ${b})`;
            modeButton.style.color = textColor;
            mapButton.style.color = textColor;
            playButton.style.color = textColor;

            const invertedColor = { r: 224, g: 224, b: 224 }; // #e0e0e0
            const invertedStyle = `rgb(${invertedColor.r}, ${invertedColor.g}, ${invertedColor.b})`;
            modeButton.style.backgroundColor = invertedStyle;
            mapButton.style.backgroundColor = invertedStyle;
            playButton.style.backgroundColor = invertedStyle;

            countdownDisplay.style.color = invertedStyle;
            countdownDisplay.style.textShadow = `0 0 10px rgb(${r}, ${g}, ${b})`;

            return { r, g, b, inverted: invertedColor };
        }

        function getCircleColor(counterColor) {
            if (counterColor === 'rgb(11, 74, 28)') return 'rgb(11, 74, 28)';
            if (counterColor === 'rgb(130, 33, 33)') return 'rgb(130, 33, 33)';
            return `rgb(224, 224, 224)`; // #e0e0e0
        }

        function lightenColor(color) {
            if (color === 'rgb(11, 74, 28)') return 'rgba(11, 74, 28,';
            if (color === 'rgb(130, 33, 33)') return 'rgba(130, 33, 33,';
            return 'rgba(224, 224, 224,'; // Based on #e0e0e0
        }

        function drawScene(color) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = `rgb(${color.inverted.r}, ${color.inverted.g}, ${color.inverted.b})`;
            ctx.lineWidth = borderWidth * 2;
            if (currentMap === 'rectangle') {
                ctx.strokeRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            } else {
                ctx.beginPath();
                ctx.arc((canvas.width / (window.devicePixelRatio || 1)) / 2, (canvas.height / (window.devicePixelRatio || 1)) / 2, Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth, 0, Math.PI * 2);
                ctx.stroke();
            }

            const greenColor = 'rgb(11, 74, 28)';
            let counterColor = '#e0e0e0';
            if (wallHits === level) counterColor = greenColor;
            else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';

            const circleColor = getCircleColor(counterColor);
            const trailBaseColor = lightenColor(circleColor);

            if (trail.length > 1) {
                ctx.beginPath();
                ctx.lineWidth = circle.radius * 2;
                ctx.lineCap = 'round';
                for (let i = 0; i < trail.length - 1; i++) {
                    const start = trail[i];
                    const end = trail[i + 1];
                    const opacity = start.opacity * (1 - (i / trail.length));
                    ctx.strokeStyle = `${trailBaseColor} ${opacity})`;
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }

            // Draw the circle with white glow
            ctx.beginPath();
            const pixelRatio = window.devicePixelRatio || 1;
            ctx.shadowColor = '#fff'; // Always white glow
            ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio; // 5px for white, 10px for green/red
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            ctx.fillStyle = circleColor;
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0; // Reset glow

            const shouldShowHoldingText = (!isPaused && circle.isDragging) || (isPaused && circle.wasDraggingWhenPaused);
            if (shouldShowHoldingText) {
                const text = "HOLDING";
                const fontSize = 24;
                const textRadius = circle.radius + 60; // Increased spacing
                const totalLetters = text.length * 4;
                const anglePerLetter = (2 * Math.PI) / totalLetters;

                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = `rgb(${color.inverted.r}, ${color.inverted.g}, ${color.inverted.b})`;
                ctx.shadowColor = '#fff'; // Always white glow
                ctx.shadowBlur = 5 * pixelRatio; // Consistent with other white glows
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                const startAngles = [
                    -Math.PI / 2,
                    0,
                    Math.PI / 2,
                    Math.PI
                ];

                for (let instance = 0; instance < 4; instance++) {
                    const startAngle = startAngles[instance];
                    for (let i = 0; i < text.length; i++) {
                        const angle = startAngle + (i * anglePerLetter);
                        const x = circle.x + textRadius * Math.cos(angle);
                        const y = circle.y + textRadius * Math.sin(angle);

                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle + Math.PI / 2);
                        ctx.fillText(text[i], 0, 0);
                        ctx.restore();
                    }
                }
                ctx.shadowBlur = 0; // Reset glow
            }

            const offset = circle.radius + 30; // Increased spacing

            ctx.font = 'bold 40px Impact, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = counterColor;
            ctx.shadowColor = '#fff'; // Always white glow
            ctx.shadowBlur = (counterColor === '#e0e0e0' ? 5 : 10) * pixelRatio; // 5px for white, 10px for green/red
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            // Add extra shadow for green/red numbers
            if (counterColor === 'rgb(11, 74, 28)') {
                ctx.shadowColor = 'rgb(50, 200, 100)';
                ctx.shadowBlur = 2 * pixelRatio;
                ctx.fillText(wallHits, circle.x, circle.y - offset);
                ctx.fillText(wallHits, circle.x, circle.y + offset);
                ctx.fillText(wallHits, circle.x - offset, circle.y);
                ctx.fillText(wallHits, circle.x + offset, circle.y);
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10 * pixelRatio;
            } else if (counterColor === 'rgb(130, 33, 33)') {
                ctx.shadowColor = 'rgb(255, 80, 80)';
                ctx.shadowBlur = 2 * pixelRatio;
                ctx.fillText(wallHits, circle.x, circle.y - offset);
                ctx.fillText(wallHits, circle.x, circle.y + offset);
                ctx.fillText(wallHits, circle.x - offset, circle.y);
                ctx.fillText(wallHits, circle.x + offset, circle.y);
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10 * pixelRatio;
            }
            ctx.fillText(wallHits, circle.x, circle.y - offset);
            ctx.fillText(wallHits, circle.x, circle.y + offset);
            ctx.fillText(wallHits, circle.x - offset, circle.y);
            ctx.fillText(wallHits, circle.x + offset, circle.y);

            ctx.fillStyle = greenColor;
            ctx.shadowColor = 'rgb(50, 200, 100)';
            ctx.shadowBlur = 2 * pixelRatio;
            ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10 * pixelRatio;
            ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y - offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x - offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);
            ctx.fillText(level, circle.x + offset * Math.sqrt(2) / 2, circle.y + offset * Math.sqrt(2) / 2);

            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function updatePhysics() {
            if (isPaused || isFleepSequence) {
                if (circle.isDragging) {
                    circle.dx = 0;
                    circle.dy = 0;
                }
                return;
            }

            const currentTime = Date.now();

            if (!circle.isDragging) {
                circle.dy += gravity;
                circle.x += circle.dx;
                circle.y += circle.dy;
                circle.dx *= friction;
                circle.dy *= friction;

                const velocity = Math.sqrt(circle.dx * circle.dx + circle.dy * circle.dy);
                const trailLength = Math.min(maxTrailLength, Math.floor(velocity / 10));
                trail.unshift({ x: circle.x, y: circle.y, opacity: 1 });
                while (trail.length > trailLength) trail.pop();
                for (let i = 0; i < trail.length; i++) {
                    trail[i].opacity -= trailFadeRate;
                    if (trail[i].opacity <= 0) trail.splice(i, 1);
                }

                let walls;
                if (currentMap === 'rectangle') {
                    walls = [
                        { name: 'right', edge: canvas.width / (window.devicePixelRatio || 1), pos: circle.x + circle.radius, velocity: circle.dx, isContact: circle.x + circle.radius >= canvas.width / (window.devicePixelRatio || 1) },
                        { name: 'left', edge: 0, pos: circle.x - circle.radius, velocity: circle.dx, isContact: circle.x - circle.radius <= 0 },
                        { name: 'bottom', edge: canvas.height / (window.devicePixelRatio || 1), pos: circle.y + circle.radius, velocity: circle.dy, isContact: circle.y + circle.radius >= canvas.height / (window.devicePixelRatio || 1) },
                        { name: 'top', edge: 0, pos: circle.y - circle.radius, velocity: circle.dy, isContact: circle.y - circle.radius <= 0 }
                    ];
                } else {
                    const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                    const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                    const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                    const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                    const isContact = distFromCenter + circle.radius >= radius;
                    walls = [{ name: 'boundary', edge: radius, pos: distFromCenter + circle.radius, velocity: 0, isContact }];
                }

                walls.forEach(wall => {
                    const contact = circle.wallContact[wall.name];
                    if (wall.isContact) {
                        if (!contact.inContact) {
                            contact.inContact = true;
                            contact.time = currentTime;
                            console.log(`Wall hit detected: ${wall.name}, isTrackingHits: ${isTrackingHits}`);
                            if (isTrackingHits) {
                                wallHits++;
                                wallHitsDisplay.textContent = `${wallHits}`;
                                const greenColor = 'rgb(11, 74, 28)';
                                let counterColor = '#e0e0e0';
                                if (wallHits === level) counterColor = greenColor;
                                else if (wallHits > level) counterColor = 'rgb(130, 33, 33)';
                                wallHitsDisplay.style.color = counterColor;
                                if (counterColor === '#e0e0e0') {
                                    wallHitsDisplay.classList.remove('bright-glow');
                                    wallHitsDisplay.style.textShadow = '0 0 5px #fff'; // White glow for white
                                } else {
                                    wallHitsDisplay.classList.add('bright-glow');
                                    const outlineColor = counterColor === greenColor ? 'rgb(50, 200, 100)' : 'rgb(255, 80, 80)';
                                    wallHitsDisplay.style.setProperty('--outline-color', outlineColor);
                                    wallHitsDisplay.style.textShadow = `0 0 10px #fff, 0 0 2px ${outlineColor}`; // White glow + outline
                                }
                                if (wallHits > level && currentMode === 'survival') {
                                    const text = lives === 3 ? 'sighhh' : lives === 2 ? 'SighhhAFF' : 'SIGHHH me to FLEEP';
                                    showText(text);
                                }
                            }
                        }
                    } else {
                        if (contact.inContact) {
                            contact.inContact = false;
                        }
                    }
                });

                if (currentMap === 'rectangle') {
                    if (circle.x + circle.radius > canvas.width / (window.devicePixelRatio || 1)) {
                        circle.x = (canvas.width / (window.devicePixelRatio || 1)) - circle.radius;
                        circle.dx = -circle.dx * bounciness;
                    } else if (circle.x - circle.radius < 0) {
                        circle.x = circle.radius;
                        circle.dx = -circle.dx * bounciness;
                    }
                    if (circle.y + circle.radius > canvas.height / (window.devicePixelRatio || 1)) {
                        circle.y = (canvas.height / (window.devicePixelRatio || 1)) - circle.radius;
                        circle.dy = -circle.dy * bounciness;
                    } else if (circle.y - circle.radius < 0) {
                        circle.y = circle.radius;
                        circle.dy = -circle.dy * bounciness;
                    }
                } else {
                    const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                    const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                    const radius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth;
                    const distFromCenter = Math.sqrt((circle.x - centerX) ** 2 + (circle.y - centerY) ** 2);
                    if (distFromCenter + circle.radius >= radius) {
                        const angle = Math.atan2(circle.y - centerY, circle.x - centerX);
                        circle.x = centerX + Math.cos(angle) * (radius - circle.radius);
                        circle.y = centerY + Math.sin(angle) * (radius - circle.radius);
                        const speed = Math.sqrt(circle.dx ** 2 + circle.dy ** 2);
                        circle.dx = -Math.cos(angle) * speed * bounciness;
                        circle.dy = -Math.sin(angle) * speed * bounciness;
                    }
                }
            }
        }

        function startCountdown(isResuming = false) {
            if (!isResuming) {
                isCountingDown = true;
                countdown = 3;
                wallHits = 0;
                wallHitsDisplay.textContent = `${wallHits}`;
                wallHitsDisplay.style.color = '#e0e0e0';
                wallHitsDisplay.classList.remove('bright-glow');
                wallHitsDisplay.style.textShadow = '0 0 5px #fff'; // Reset to white glow
                isTrackingHits = true;
                countdownOpacity = 1;
                shownTexts.clear();
                sighhhVisible = false;
            } else {
                isCountingDown = true;
            }
            countdownDisplay.style.opacity = countdownOpacity;
            countdownDisplay.textContent = countdown;

            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDisplay.textContent = countdown;
                } else {
                    countdownOpacity = 0;
                    countdownDisplay.style.opacity = countdownOpacity;
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    isCountingDown = false;
                    updateDisplay();
                }
            }, 1000);
        }

        function getMousePos(e, touchId = null) {
            const rect = canvas.getBoundingClientRect();
            if (touchId !== null && e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        return {
                            x: e.touches[i].clientX - rect.left,
                            y: e.touches[i].clientY - rect.top
                        };
                    }
                }
            }
            return {
                x: (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left,
                y: (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top
            };
        }

        function getScreenPos(e, touchId = null) {
            let touches = e.touches || e.changedTouches;
            if (touchId !== null && touches) {
                for (let i = 0; i < touches.length; i++) {
                    if (touches[i].identifier === touchId) {
                        return {
                            x: touches[i].clientX,
                            y: touches[i].clientY
                        };
                    }
                }
            }
            return {
                x: e.clientX || (touches && touches[0].clientX),
                y: e.clientY || (touches && touches[0].clientY)
            };
        }

        function isOverButton(x, y, button) {
            const rect = button.getBoundingClientRect();
            return (
                x >= rect.left &&
                x <= rect.right &&
                y >= rect.top &&
                y <= rect.bottom
            );
        }

        function handleCircleTap(e) {
            if (isPaused || isFleepSequence) return;
            const pos = getMousePos(e);
            const dist = Math.sqrt((pos.x - circle.x) ** 2 + (pos.y - circle.y) ** 2);
            if (dist < circle.radius && (!circle.isDragging || (e.touches && e.touches.length === 1))) {
                console.log('Circle tapped');
                e.preventDefault();
                if (isTrackingHits) {
                    if (isCountingDown) {
                        if (wallHits === level) {
                            isTrackingHits = false;
                            isCountingDown = false;
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            countdownOpacity = 0;
                            countdownDisplay.style.opacity = countdownOpacity;
                            const completedLevel = level;
                            level++;
                            if (currentMode === 'survival') {
                                lives = 3;
                                showText('yee haw BII');
                            }
                            if (completedLevel > hiScore) hiScore = completedLevel;
                            wallHits = 0;
                            saveState();
                            updateDisplay();
                            startCountdown();
                        }
                    } else {
                        isTrackingHits = false;
                        const previousWallHits = wallHits;
                        const previousLives = lives;
                        if (wallHits === level) {
                            const completedLevel = level;
                            level++;
                            if (currentMode === 'survival') {
                                lives = 3;
                                showText('yee haw BII');
                            }
                            if (completedLevel > hiScore) hiScore = completedLevel;
                            wallHits = 0;
                        } else if (currentMode === 'survival') {
                            lives--;
                            let text = '';
                            if (previousLives === 3 && lives === 2) {
                                text = 'sighhh';
                            } else if (previousLives === 2 && lives === 1) {
                                text = 'SighhhAFF';
                            } else if (lives <= 0) {
                                level = 1;
                                lives = 3;
                                text = 'SIGHHH me to FLEEP';
                            }
                            if (text) showText(text);
                        }
                        saveState();
                        updateDisplay();
                        startCountdown();
                    }
                } else if (!isCountingDown) {
                    wallHits = 0;
                    startCountdown();
                }
            }
        }

        function startDragging(e) {
            if (isFleepSequence || (isPaused && !circle.wasDraggingWhenPaused)) return;
            const pos = getMousePos(e, e.touches ? e.touches[0].identifier : null);
            const dist = Math.sqrt((pos.x - circle.x) ** 2 + (pos.y - circle.y) ** 2);
            if (dist < circle.radius) {
                e.preventDefault();
                circle.isDragging = true;
                circle.dragTouchId = e.touches ? e.touches[0].identifier : null;
                circle.lastX = pos.x;
                circle.lastY = pos.y;
                circle.lastTime = Date.now();
                circle.dx = 0;
                circle.dy = 0;
                if (!isPaused) trail.length = 0;

                // Reset button activation flags
                buttonActivated = { play: false, mode: false, map: false };
                console.log('Dragging started, touchId:', circle.dragTouchId);
            }
        }

        function startResizing(e) {
            if (!circle.isDragging || circle.isResizing || isFleepSequence || e.touches.length < 2) return;
            if (isPaused && !circle.wasDraggingWhenPaused) return;

            const dragTouchIndex = Array.from(e.touches).findIndex(t => t.identifier === circle.dragTouchId);
            if (dragTouchIndex === -1) return;

            const otherTouch = e.touches[dragTouchIndex === 0 ? 1 : 0];
            const pos = getMousePos(e, otherTouch.identifier);
            const canvasRect = canvas.getBoundingClientRect();
            const isOverCanvas = (
                otherTouch.clientX >= canvasRect.left &&
                otherTouch.clientX <= canvasRect.right &&
                otherTouch.clientY >= canvasRect.top &&
                otherTouch.clientY <= canvasRect.bottom
            );

            if (isOverCanvas) {
                circle.resizeTouchId = otherTouch.identifier;
                circle.resizeStartX = pos.x;
                circle.resizeStartY = pos.y;
                circle.initialRadius = circle.radius;
                circle.resizeStartTime = Date.now();
                circle.resizeTimer = setTimeout(() => {
                    if (circle.resizeTouchId !== null) {
                        circle.isResizing = true;
                        console.log('Resizing started, resizeTouchId:', circle.resizeTouchId);
                    }
                }, resizeHoldThreshold);
                console.log('Resize touch initiated, waiting for hold threshold');
            }
        }

        function drag(e) {
            if (isFleepSequence) return;

            if (circle.isDragging && !circle.isResizing) {
                const pos = getMousePos(e, circle.dragTouchId);

                if (currentMap === 'rectangle') {
                    pos.x = Math.max(circle.radius, Math.min((canvas.width / (window.devicePixelRatio || 1)) - circle.radius, pos.x));
                    pos.y = Math.max(circle.radius, Math.min((canvas.height / (window.devicePixelRatio || 1)) - circle.radius, pos.y));
                } else {
                    const centerX = (canvas.width / (window.devicePixelRatio || 1)) / 2;
                    const centerY = (canvas.height / (window.devicePixelRatio || 1)) / 2;
                    const maxRadius = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1) / 2 - borderWidth - circle.radius;
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > maxRadius) {
                        const angle = Math.atan2(dy, dx);
                        pos.x = centerX + Math.cos(angle) * maxRadius;
                        pos.y = centerY + Math.sin(angle) * maxRadius;
                    }
                }

                circle.x = pos.x;
                circle.y = pos.y;

                if (!isPaused) {
                    const currentTime = Date.now();
                    const dt = (currentTime - circle.lastTime) / 1000;
                    if (dt > 0) {
                        circle.dx = (pos.x - circle.lastX) / dt;
                        circle.dy = (pos.y - circle.lastY) / dt;
                    }
                    circle.lastX = pos.x;
                    circle.lastY = pos.y;
                    circle.lastTime = currentTime;
                }

                // Check if the finger is over a button during drag
                const screenPos = getScreenPos(e, circle.dragTouchId);
                buttonActivated.play = isOverButton(screenPos.x, screenPos.y, playButton);
                buttonActivated.mode = isOverButton(screenPos.x, screenPos.y, modeButton);
                buttonActivated.map = isOverButton(screenPos.x, screenPos.y, mapButton);
            }

            if (circle.isResizing) {
                const pos = getMousePos(e, circle.resizeTouchId);
                const dx = pos.x - circle.resizeStartX;
                const dy = pos.y - circle.resizeStartY;
                const distanceDelta = Math.sqrt(dx * dx + dy * dy) * (dx < 0 || dy < 0 ? -1 : 1);
                const newRadius = Math.max(defaultRadius, circle.initialRadius + distanceDelta / 2);
                circle.radius = newRadius;
                constrainCircle();
            }
        }

        function stopDragging(e) {
            if (isFleepSequence) return;

            let touchId = e.changedTouches ? e.changedTouches[0].identifier : null;
            if (touchId === null && !e.touches) {
                // Mouse release
                circle.isDragging = false;
                circle.dragTouchId = null;
                circle.isResizing = false;
                circle.resizeTouchId = null;
                if (circle.resizeTimer) {
                    clearTimeout(circle.resizeTimer);
                    circle.resizeTimer = null;
                }
                console.log('Dragging stopped (mouse)');
                return;
            }

            if (circle.isDragging && touchId === circle.dragTouchId) {
                const screenPos = getScreenPos(e, circle.dragTouchId);
                console.log('Release position:', screenPos, 'buttonActivated:', buttonActivated);

                // Check if releasing over a button and activate if true
                if (buttonActivated.play && isOverButton(screenPos.x, screenPos.y, playButton)) {
                    console.log('Activating playButton');
                    togglePause();
                }
                if (buttonActivated.mode && isOverButton(screenPos.x, screenPos.y, modeButton)) {
                    console.log('Activating modeButton');
                    toggleMode();
                }
                if (buttonActivated.map && isOverButton(screenPos.x, screenPos.y, mapButton)) {
                    console.log('Activating mapButton');
                    toggleMap();
                }

                circle.isDragging = false;
                circle.dragTouchId = null;
                console.log('Dragging stopped, touchId:', touchId);
            }

            if (circle.isResizing && touchId === circle.resizeTouchId) {
                circle.isResizing = false;
                circle.resizeTouchId = null;
                if (circle.resizeTimer) {
                    clearTimeout(circle.resizeTimer);
                    circle.resizeTimer = null;
                }
                console.log('Resizing stopped, touchId:', touchId);
            }
        }

        canvas.addEventListener('mousedown', startDragging);
        canvas.addEventListener('touchstart', (e) => {
            startDragging(e);
            startResizing(e);
        });
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('touchmove', drag);
        canvas.addEventListener('mouseup', stopDragging);
        canvas.addEventListener('touchend', stopDragging);
        canvas.addEventListener('click', handleCircleTap);
        canvas.addEventListener('touchend', handleCircleTap);

        function togglePause() {
            if (isFleepSequence) return;
            if (isPaused) {
                isPaused = false;
                circle.wasDraggingWhenPaused = false;
                playButton.classList.remove('glow-green', 'glow-red');
                void playButton.offsetHeight; // Trigger reflow to restart animation
                playButton.classList.add('glow-red');
                if (isCountingDown) {
                    startCountdown(true);
                }
            } else {
                isPaused = true;
                circle.wasDraggingWhenPaused = circle.isDragging;
                playButton.classList.remove('glow-green', 'glow-red');
                void playButton.offsetHeight; // Trigger reflow to restart animation
                playButton.classList.add('glow-green');
                if (isCountingDown) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
            }
            updateDisplay();
        }

        playButton.addEventListener('click', togglePause);
        playButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            togglePause();
        });

        function toggleMode() {
            if (isFleepSequence) return;
            saveState();
            currentMode = currentMode === 'survival' ? 'endurance' : 'survival';
            loadState(currentMode, currentMap);
            modeButton.classList.remove('glow-white');
            void modeButton.offsetHeight; // Trigger reflow to restart animation
            modeButton.classList.add('glow-white');
        }

        modeButton.addEventListener('click', toggleMode);
        modeButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleMode();
        });

        function toggleMap() {
            if (isFleepSequence) return;
            saveState();
            currentMap = currentMap === 'rectangle' ? 'circle' : 'rectangle';
            loadState(currentMode, currentMap);
            mapButton.classList.remove('glow-white');
            void mapButton.offsetHeight; // Trigger reflow to restart animation
            mapButton.classList.add('glow-white');
        }

        mapButton.addEventListener('click', toggleMap);
        mapButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleMap();
        });

        function animate() {
            updatePhysics();
            drawScene(updateColors());
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
